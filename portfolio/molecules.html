<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<link href="https://unpkg.com/uplot/dist/uPlot.min.css" rel="stylesheet">
<script src="https://unpkg.com/uplot/dist/uPlot.iife.min.js"></script>


<canvas class="applicationCanvas" id="simulationCanvas"></canvas><br/>
<p style="clear: both;"></p>
<div class="buttonRow">
    <button id="pauseButton">&nbsp;Pause&nbsp;</button>
    <button id="bondTypeButton">Bonds as springs</button>
</div>
<p style="clear: both;"></p>
<!--div class="buttonRow">
    <label for="temperatureSlider">Temperature (K): </label>
    <input type="range" id="temperatureSlider" min="10" max="1000" value="298" step="1">
    <span id="temperatureValue">298</span> K
</div>
<p style="clear: both;"></p-->
<div id="energyPlot" style="margin:auto;"></div>

<script type="module">
    import { Group, Scene, Vector3, PerspectiveCamera, WebGLRenderer, DirectionalLight, AmbientLight,
        MeshStandardMaterial, Mesh, BoxGeometry, Color, EdgesGeometry, LineBasicMaterial, LineSegments
    }  from "three";
    import { CarbonMonoxide, Bond, Aquarium } from "https://www.hendrikse.name/science/js/three-js-extensions.js";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // Simulation constants
    const SCALE = 1e10; // For display
    const MOLECULES_COUNT = 80;
    const one_third = 1. / 3.;
    const L = ((24.4E-3 / 6E23) * MOLECULES_COUNT) ** one_third / 50; // 2L is the length of the cubic container box

    console.clear( );
    const scene = new Scene();
    const vector = Vector3;

    const canvas = document.getElementById('simulationCanvas');
    canvas.focus();
    const canvasWidth = canvas.clientWidth;
    const canvasHeight = canvas.clientHeight;

    const camera = new PerspectiveCamera(60, canvasWidth/canvasHeight, 0.1, 1000);
    camera.position.set(4.25, 1.25, 7.25);
    camera.updateProjectionMatrix();

    const renderer = new WebGLRenderer( {antialias: true, canvas: canvas, alpha: true} );
    renderer.setSize( canvasWidth, canvasHeight );
    renderer.setAnimationLoop( animationLoop );

    const controls = new OrbitControls( camera, canvas );
    controls.enableDamping = true;

    const light = new DirectionalLight(0xffffff, 1);
    light.position.set(0, 4 * L * SCALE, 0);
    scene.add(light);
    scene.add(new AmbientLight(0xffffff, .5));
    new Aquarium(scene, {size: 2 * L * SCALE});

    class CarbonMonoxideGas extends Group {
        constructor(moleculeCount=MOLECULES_COUNT, temperature=298, boxSize=L) {
            super();
            this._molecules = [];
            this._boxSize = boxSize;
            this._temperature = temperature;
            const mass = 14E-3 / 6E23; // Average mass of Oxygen and Carbon
            const k = 1.38E-23; // Boltzmann constant
            for (let i = 0; i < moleculeCount; i++) {
                const pos = new vector(Math.random() -.5, Math.random() -.5, Math.random() -.5).multiplyScalar(boxSize);
                const molecule = new CarbonMonoxide(pos, Math.sqrt(3 * k * temperature / mass), SCALE);
                this._molecules.push(molecule);
                this.add(molecule);
            }
        }

        update(dt) {
            for (let molecule of this._molecules) {
                molecule.timelapse(dt);
                molecule.checkBoxBounce(this._boxSize * 2);
            }

            for (let i = 0; i < this._molecules.length; i++)
                for (let j = i + 1; j < this._molecules.length; j++)
                    this._molecules[i].resolveCollisionWith(this._molecules[j]);
        }

        updateToNewTemperature(newTemperature) {
            // Modify the speed of all molecules according to equipartition: v ~ sqrt(T)
            const scaleFactor = Math.sqrt(newTemperature / this._temperature); // ratio new temp / old temp
            for (let molecule of this._molecules)
                molecule.scaleVelocity(scaleFactor);
            this._temperature = newTemperature;
        }

        changeBondType(type) {
            for (let molecule of this._molecules)
                molecule.changeBondType(type);
            this.update(0);
        }

        translationalKE() { return this._molecules.reduce((sum, m) => sum + m.translationalKE(), 0); }
        vibrationalKE() { return this._molecules.reduce((sum, m) => sum + m.vibrationalKE(), 0); }
        vibrationalPE() { return this._molecules.reduce((sum, m) => sum + m.vibrationalPE(), 0); }
        rotationalKE() { return this._molecules.reduce((sum, m) => sum + m.rotationalKE(), 0); }
    }

    const opts = {
        title: "Kinetic Energy vs Time",
        width: canvas.clientWidth,
        height: canvas.clientHeight * .75,
        bg: "transparent",
        scales: { x: { auto: true }, y: { auto: true } },
        axes: [
            {
                stroke: "#ff0",
                font: "12px Arial",
                grid: {stroke: "rgba(255, 255, 255, 0.2)", width: 1},
                label: "Time [ps]", values: (u, values) => values.map(value=> value.toFixed(2))
            },
            {
                stroke: "#ff0",
                font: "12px Arial",
                grid: {stroke: "rgba(255, 255, 255, 0.2)", width: 1},
                label: "KE [J]", values: (u, values) => values.map(value => value.toExponential(2))
            }
        ],
        series: [
            { label: "t" },
            { label: "Translational KE", stroke: "green" },
            { label: "Vibrational PE", stroke: "red" },
            { label: "Vibrational KE", stroke: "cyan" },
            { label: "Rotational KE", stroke: "yellow" }
        ]
    };

    const gas = new CarbonMonoxideGas();
    scene.add(gas);
    const energyData = { time: [], translational: [], vPE: [], vKE: [], rotational: [] };
    const uplotChart = new uPlot(opts, [energyData.time, energyData.translational, energyData.vPE, energyData.vKE, energyData.rotational], document.getElementById("energyPlot"));

    // UI
    // const tempSlider = document.getElementById("temperatureSlider");
    // const tempValueLabel = document.getElementById("temperatureValue");
    //tempSlider.addEventListener("input", () => {
    //    const newTemperature = parseFloat(tempSlider.value) + "";
    //    tempValueLabel.textContent = newTemperature;
    //    gas.updateToNewTemperature(newTemperature);
    //});
    let running = true;
    const toggleButton = document.getElementById("pauseButton");
    toggleButton.onclick = () => {
        running = !running;
        toggleButton.innerHTML = running ? "&nbsp;Pause&nbsp;" : "Resume";
    }
    let bondType = Bond.Type.CYLINDER;
    const bondTypeButton = document.getElementById("bondTypeButton");
    bondTypeButton.onclick = () => {
        bondType = bondType === Bond.Type.CYLINDER ? Bond.Type.SPRING : Bond.Type.CYLINDER;
        bondTypeButton.innerHTML = bondType === Bond.Type.SPRING ? "&nbsp;Bonds as rods&nbsp;" : "Bonds as springs";
        gas.changeBondType(bondType);
    }

    const dt = 5e-16;
    let t = 0,
        steps = 0,
        totalTranslational = 0,
        totalVibrationalKE = 0,
        totalVibrationalPE = 0,
        totalRotational = 0;

    function iterate() {
        for (let i = 0; i < 15; i++) {
            gas.update(dt);
            t += dt;

            totalTranslational += gas.translationalKE();
            totalVibrationalKE += gas.vibrationalKE();
            totalVibrationalPE += gas.vibrationalPE();
            totalRotational += gas.rotationalKE();
            steps++;
        }


        if (steps % 150 === 0) {
            energyData.time.push(t * SCALE);
            energyData.translational.push(totalTranslational / steps);
            energyData.vPE.push(totalVibrationalPE / steps);
            energyData.vKE.push(totalVibrationalKE / steps);
            energyData.rotational.push(totalRotational / steps);
            uplotChart.setData([energyData.time, energyData.translational, energyData.vPE, energyData.vKE, energyData.rotational]);
        }
    }

    function animationLoop() {
        renderer.render(scene, camera);
        controls.update();

        if (running) iterate();
    }


</script>