<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="planetControls">
    <div class="buttonRow">
        <button data-body="sun">ğŸ”… Sun</button>
        <button data-body="mercury">Mercury</button>
        <button data-body="venus">Venus</button>
        <button data-body="earth">ğŸŒ Earth</button>
        <button data-body="mars">Mars</button>
        <button id="farField1">ğŸ”­</button>
    </div>

    <canvas class="applicationCanvas" id="planetsCanvas"  style="aspect-ratio: 19 / 12;"></canvas>

    <div class="buttonRow">
        <button id="farField2">ğŸ’«</button>
        <button data-body="jupiter">Jupiter</button>
        <button data-body="saturn">ğŸª Saturn</button>
        <button data-body="uranus">Uranus</button>
        <button data-body="neptune">ğŸ”± Neptune</button>
        <button id="zoomIn">ğŸ”</button>
    </div>
</div>
<div class="guiContainer" id="solarSystemGui"></div>

<script type="module">
    import { Group, SphereGeometry, Mesh, Scene, PerspectiveCamera, Vector3, WebGLRenderer,
        AmbientLight, PointLight, DoubleSide, SRGBColorSpace, ACESFilmicToneMapping,
        MeshBasicMaterial, Sprite, SpriteMaterial, CanvasTexture, RingGeometry} from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { ThreeJsUtils } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { SkyDome, Earth, Planet, Moon, Sun, PlanetMoonSystem, Saturn, Uranus, SCALE_MOON }
        from 'https://www.hendrikse.name/science/js/astro-extensions.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const planetsCanvas = document.getElementById('planetsCanvas');
    planetsCanvas.focus();
    console.clear();

    const capitalizeFirstLetter = (string) => String(string).charAt(0).toUpperCase() + String(string).slice(1);
    const toSuperscript = (num) => {
        const map = {
            '-': 'â»',
            '0': 'â°',
            '1': 'Â¹',
            '2': 'Â²',
            '3': 'Â³',
            '4': 'â´',
            '5': 'âµ',
            '6': 'â¶',
            '7': 'â·',
            '8': 'â¸',
            '9': 'â¹'
        };
        return String(num).split('').map(c => map[c] || '').join('');
    }

    let timeScale = 24; // 24 hours equal to one second simulation time

    const planetaryScene = new Scene();
    // --- CAMERA ---
    const cameraStart = {
        position: new Vector3(580, 200, -195),
        target: new Vector3(0, 0, 0)
    };
    const planetCamera = new PerspectiveCamera(50, 1, .1, 5000);
    planetCamera.position.copy(cameraStart.position);

    const planetRenderer = new WebGLRenderer( {antialias: true, canvas: planetsCanvas, alpha: true} );
    planetRenderer.shadowMap.enabled = false;
    planetRenderer.setAnimationLoop( animate );
    planetRenderer.toneMapping = ACESFilmicToneMapping;
    planetRenderer.toneMappingExposure = 1.5;
    planetRenderer.outputColorSpace = SRGBColorSpace;
    planetRenderer.shadowMap.enabled = true;

    // Resizing for mobile devices
    ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    window.addEventListener('resize', () => {
        ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    });

    const controls = new OrbitControls(planetCamera, planetsCanvas);
    controls.target.copy(cameraStart.target);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const skyDome = new SkyDome({starDensity: 1, skyRadius: 4950, glowStarCount: 500});
    planetaryScene.add(skyDome);

    export class LunarEclipseIndicator {
        constructor(earth, moon, plane) {
            this._earth = earth;
            this._moon = moon;
            this._plane = plane; // equatorial plane
            this._threshold = earth.scaledRadius * 0.05; // Â± 5% van straal
            this._active = false;

            // tiny ball as indicator
            const geom = new SphereGeometry(this._threshold * 0.5, 16, 16);
            const mat = new MeshBasicMaterial({ color: 0xff0000 });
            this._indicator = new Mesh(geom, mat);
            this._indicator.visible = false;
            planetaryScene.add(this._indicator);
        }

        update() {
            const moonPosLocal = this._earth.worldToLocal(this._moon.getWorldPosition(new Vector3()));
            const distanceToPlane = Math.abs(moonPosLocal.y); // y = hoogte t.o.v. equator

            if (distanceToPlane < this._threshold) {
                this._indicator.visible = true;
                this._indicator.position.copy(this._moon.position);
                this._active = true;
                this._plane.material.color.set(0xff0000); // plane tijdelijk rood
            } else {
                this._indicator.visible = false;
                this._active = false;
                this._plane.material.color.set(0x00ffff); // originele plane kleur
            }
        }
    }

    class ControlsGui {
        constructor() {
            const controls = new GUI({width: "100%", autoPlace: false});
            document.getElementById("solarSystemGui").appendChild(controls.domElement);
            this._zoomInOnObject = null;
            this._label = null;
            this._objectInFocus = null;
            this._focusOffset = null;

            const settings = { timeScale: 24, equatorialPlane: false, eclipticPlane: false, earthClouds: false };
            controls.add(settings, 'timeScale', 0, 240, 1)
                .name("Simulated hours per second")
                .onChange(value => timeScale = value);
            controls.add(settings, 'equatorialPlane')
                .name("Equatorial plane")
                .onChange(value => earth.equatorialPlane.visible = value);
            controls.add(settings, 'earthClouds')
                .name("Earth clouds")
                .onChange(value => earth.clouds.visible = value);
            controls.add(settings, 'eclipticPlane')
                .name("Ecliptic plane")
                .onChange(value => eclipticPlane.material.visible = value);
        }

        #formatScientific(value, unit = '') {
            if (!value) return 'â€”';
            const [mantissa, exp] = value.toExponential(2).split('e');
            return `${mantissa} x 10${toSuperscript(exp)} ${unit}`;
        }

        #formatBodyInfo(body) {
            const name = capitalizeFirstLetter(body._name);
            return `
                ${name}
                Mass: ${this.#formatScientific(body._mass, 'kg')}
                Radius: ${(body._radius / 1000).toFixed(0)} km
                `;
        }

        #createInfoLabel(text, {
            font = 'bold 24px system-ui',
            color = '#ffff00',
            background = 'rgba(0, 0, 0, 0)',
            padding = 80
        } = {}) {

            const lines = text.split('\n');
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            context.font = font;
            const lineHeight = 26;
            const width = Math.max(...lines.map(line => context.measureText(line).width));

            canvas.width  = width + padding * 2;
            canvas.height = lines.length * lineHeight + padding * 2;
            context.font = font;
            context.fillStyle = background;
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = color;
            context.textBaseline = 'top';

            lines.forEach((line, i) => context.fillText(line, padding, padding + i * lineHeight));

            const texture = new CanvasTexture(canvas);
            texture.colorSpace = SRGBColorSpace;

            const material = new SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });

            const sprite = new Sprite(material);
            sprite.scale.set(canvas.width * 0.015, canvas.height * 0.015, 1);
            return sprite;
        }

        #labelPositionFrom = (object) => object.position.clone()
            .add(new Vector3(0, object.scaledRadius, object.scaledRadius).multiplyScalar(1.1));

        #createLabel(object) {
            if (!object._name) return;
            this.#removeLabel();
            this._label = this.#createInfoLabel(this.#formatBodyInfo(object));
            this._label.position.copy(this.#labelPositionFrom(object));
            this._label.scale.setScalar(3 * object.scaledRadius);
            planetaryScene.add(this._label);
        }

        #removeLabel() {
            planetaryScene.remove(this._label);
            this._label?.material.dispose();
            this._label = null;
        }

        onReset() {
            this._objectInFocus = null;
            this.#removeLabel();
        }

        onSelect(object, {
            distanceFactor = 5,
            duration = 1.2
        } = {}) {
            this._objectInFocus = object;

            const startTime = performance.now();
            const startOffset = planetCamera.position
                .clone()
                .sub(controls.target);

            const viewDirection = startOffset.clone().normalize();
            const endOffset = viewDirection.multiplyScalar(object.scaledRadius * distanceFactor);

            this.#createLabel(object);
            this._zoomInOnObject = () => {
                const time = (performance.now() - startTime) / (duration * 1000);
                const k = Math.min(time, 1);
                const step = k * k * (3 - 2 * k); // smoothstep

                this._focusOffset = startOffset.clone().lerp(endOffset, step);

                planetCamera.position
                    .copy(object.position)
                    .add(this._focusOffset);

                controls.target.copy(object.position);
                controls.update();

                if (k >= 1) this._zoomInOnObject = null;
            };
        }

        render() {
            if (this._zoomInOnObject) this._zoomInOnObject();
            if (this._label) this._label.position.copy(this.#labelPositionFrom(this._objectInFocus));
            if (this._objectInFocus) {
                planetCamera.position
                    .copy(this._objectInFocus.position)
                    .add(this._focusOffset);

                controls.target.copy(this._objectInFocus.position);
                controls.update();
            }

        }
    }

    const solarSystemGroup = new Group();
    planetaryScene.add(solarSystemGroup);

    const sun = new Sun({
        "name": "sun",
        "radius": 696300000.0,
        "mass": 1.9885440000000002e+30,
        "spin": 3600 * 2.8653290845717256e-06,
        "tilt": 0.1265363707695889
    });
    sun.position.set(0, 0, 0);
    solarSystemGroup.add(sun);
    const sunLight = new PointLight(0xffffff, 2.0, 0, .1); // intense, no max distance
    sunLight.position.set(0, 0, 0);
    sunLight.castShadow = true;
    planetaryScene.add(sunLight);
    planetaryScene.add(new AmbientLight(0xffffff, 0.1));

    const earth = new Earth();
    earth.clouds.visible = false;
    const mercury = new Planet({
        "name": "mercury",
        'a': 57909050.,
        'e': 0.205630,
        'inclination': 7 * Math.PI / 180.,
        'right_ascension': 0.8436854966,
        'mean_anomaly': 3.0507657193,
        'radius': 2439.7 * 1e3,
        "mass": 3.302e+23,
        'tilt': 0.1 * Math.PI / 180.,
        "spin": 2 * Math.PI / 4222.6
    }, {bumpScale: 0.005});
    const venus = new Planet({
        "name": "venus",
        'a': 108208000.,
        'e': 0.0067,
        'inclination': 3.39 * Math.PI / 180.,
        'right_ascension': 1.3381895772,
        'mean_anomaly': 0.8746717546,
        'radius': 6051.8 * 1e3,
        "mass": 4.8685e+23,
        'tilt': 177 * Math.PI / 180.,
        'spin':  -2 * Math.PI / 2802.
    }, {bumpScale: 0.005});
    const mars = new Planet({
        "name": "mars",
        'a': 227939100.,
        'e': 0.093315,
        'inclination': 1.85 * Math.PI / 180.,
        'right_ascension': 0.8676591934,
        'mean_anomaly': 0.3378329113,
        'radius': 3393.5 * 1e3,
        "mass": 6.4185e+23,
        'tilt': 25 * Math.PI / 180.,
        'spin': 2 * Math.PI / 24.66
    }, {bumpScale: 0.05});
    const jupiter = new Planet({
        "name": "jupiter",
        'a': 778547200.,
        'e': 0.048775,
        'inclination': 1.31 * Math.PI / 180.,
        'right_ascension': 1.7504400393,
        'mean_anomaly': 0.3284360586,
        'radius': 71400. * 1e3,
        "mass": 1.89813e+27,
        'tilt': 3 * Math.PI / 180.,
        'spin': 2 * Math.PI / 9.93
    }, {bumpScale: 0.02, identicalBumpMap: true});
    const saturn = new Saturn();
    const uranus = new Uranus();
    const neptune = new Planet({
        'name': "neptune",
        'a': 4503443661.,
        'e': 0.011214269,
        'inclination': 1.77 * Math.PI / 180.,
        'right_ascension': 2.3001058656,
        'mean_anomaly': 4.6734206826,
        'radius': 24300. * 1E3,
        "mass": 1.024E26,
        'tilt': 30 * Math.PI / 180.,
        'spin': 2 * Math.PI / 16.11,
    }, {identicalBumpMap: true, bumpScale: 0.05});

    const luna = new Moon({
        "name": "luna",
        "a": 384399 * SCALE_MOON * .2,
        "e": 0.0549,
        "inclination": (-23.4 + 5.145) * Math.PI / 180.,
        "right_ascension": -Math.PI / 2.,
        "mean_anomaly": 0.,
        "radius": 1737400,
        "mass": 7.349e+22,  // kg
        "spin": 2 * Math.PI / 708.7341666667,
        "tilt": 0.11641346110802178, // rad
        'period': 27.321, // days
        "tidal_lock": true
    }, earth);
    const phobos = new Moon({
        "name": "phobos",
        'a': 9376 * SCALE_MOON * 2.5, // 2.5 = scale up for this tiny moon
        'e': 0.0151,
        'inclination': 0,
        'right_ascension': -Math.PI / 2,
        'mean_anomaly': 0.,
        'radius': 11.2667 * 1E4 * 2, // 2 = scale up for this tiny moon
        "mass": 1.06E16,
        'tilt': 0.,
        'spin': 0,
        'period': 0.31891023,
        'tidal_lock': 1}, mars);
    const deimos = new Moon({
        'name': "deimos",
        'a': 23463.2 * SCALE_MOON * 1.5, // 1.5 = scale up for this tiny moon
        'e': 0.00033,
        'inclination': 0,
        'right_ascension': -Math.PI / 2,
        'mean_anomaly': 0.,
        'radius': 10. * 1E4 * 2, // 2 = scale up for this tiny moon
        "mass": 1.5E15,
        'tilt': 0.,
        'spin': 0,
        'period': 1.263,
        'tidal_lock': 1}, mars);
    const callisto = new Moon({
        'name': "callisto",
        'a': 1882700 * SCALE_MOON / 2,
        'e': 0.0074,
        'inclination': 0.003351032164,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 2410.3 * 1e3,
        "mass": 1.076E23,
        'tilt': 0.,
        'spin': 0,
        'period': 16.689,
        'tidal_lock': 1}, jupiter);
    const europa = new Moon({
        'name': "europa",
        'a': 670900 * SCALE_MOON,
        'e': 0.009,
        'inclination': 0.008203047484,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 1560.8 * 1e3,
        "mass": 4.8E22,
        'tilt': 0.,
        'spin': 0,
        'period': 12.689,
        'tidal_lock': 1}, jupiter);
    const ganymede = new Moon({
        'name': "ganymede",
        'a': 1070400 * SCALE_MOON,
        'e': 0.0013,
        'inclination': 0.003490658504,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 2634.1 * 1E3,
        "mass": 1.4819E23,
        'tilt': 0.,
        'spin': 0,
        'period': 10.689,
        'tidal_lock': 1}, jupiter);
    const io = new Moon({
        'name': "io",
        'a': 421800 * SCALE_MOON * 1.5,
        'e': 0.0041,
        'inclination': 0.03857177647,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 1821.6 * 1E3,
        "mass": 8.9319E22,
        'tilt': 0.,
        'spin': 0,
        'period': 6.689,
        'tidal_lock': 1
    }, jupiter);
    const dione = new Moon({
        'name': "dione",
        'a': 377396 * 3 * SCALE_MOON,
        'e': 0.0022,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 561.4 * 3 * 1e3,
        "mass": 1.095E21,
        'tilt': 0.,
        'spin': 0,
        'period': 7.689,
        'tidal_lock': 1
    }, saturn);
    const enceladus = new Moon({
        'name': "enceladus",
        'a': 237948 * 3 * SCALE_MOON,
        'e': 0.0047,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 252.1 * 3 * 1e3,
        "mass": 1.08022E20,
        'tilt': 0.,
        'spin': 0,
        'period': 16.689,
        'tidal_lock': 1
    }, saturn);
    const tethys = new Moon({
        'name': "tethys",
        'a': 294619 * 3 * SCALE_MOON,
        'e': 0.,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 531.1 * 3 * 1e3,
        "mass": 6.17E20,
        'tilt': 0.,
        'spin': 0,
        'period': 1.689,
        'tidal_lock': 1
    }, saturn);
    const titan = new Moon({
        'name': "titan",
        'a': 1221870 * SCALE_MOON,
        'e': 0.0288,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 2576. * 1E3,
        "mass": 1.345E23,
        'tilt': 0.,
        'spin': 0,
        'period': 61.689,
        'tidal_lock': 1
    }, saturn);

    const bodies = { sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune };

    const earthMoonSystem = new PlanetMoonSystem(earth, [luna]);
    solarSystemGroup.add(earthMoonSystem);
    earthMoonSystem.update(0, 1); // set initial position
    earth.enableTrail({maxPoints: 400, color: 0x00bbff, trailStep: 125});
    solarSystemGroup.add(earth.renderedOrbit(0x00bbff));

    const noMoonsMercury = new PlanetMoonSystem(mercury);
    solarSystemGroup.add(noMoonsMercury);
    noMoonsMercury.update(0, 1);
    mercury.enableTrail({maxPoints: 80, color: 0xaaff00, trailStep: 25});
    solarSystemGroup.add(mercury.renderedOrbit(0xaaff00));

    const noMoonsVenus = new PlanetMoonSystem(venus);
    solarSystemGroup.add(noMoonsVenus);
    noMoonsVenus.update(0, 1);
    venus.enableTrail({maxPoints: 120, color: 0xff0000, trailStep: 100});
    solarSystemGroup.add(venus.renderedOrbit(0xff0000));

    const marsWithMoons = new PlanetMoonSystem(mars, [phobos, deimos]);
    solarSystemGroup.add(marsWithMoons);
    marsWithMoons.update(0, 1);
    mars.enableTrail({maxPoints: 550, color: 0xffaa00, trailStep: 250});
    solarSystemGroup.add(mars.renderedOrbit(0xffaa00));

    const jupiterWithMoons = new PlanetMoonSystem(jupiter, [callisto, europa, ganymede, io]);
    solarSystemGroup.add(jupiterWithMoons);
    jupiterWithMoons.update(0, 1);
    jupiter.enableTrail({maxPoints: 1600, color: 0x8b4513, trailStep: 500});
    solarSystemGroup.add(jupiter.renderedOrbit(0x8b4513));

    const saturnWithMoons = new PlanetMoonSystem(saturn, [dione, enceladus, tethys, titan]);
    solarSystemGroup.add(saturnWithMoons);
    saturnWithMoons.update(0, 1);
    saturn.enableTrail({maxPoints: 1600, color: 0xffff00, trailStep: 500});
    solarSystemGroup.add(saturn.renderedOrbit(0xffff00));

    const uranusWithMoons = new PlanetMoonSystem(uranus, []);
    solarSystemGroup.add(uranusWithMoons);
    uranusWithMoons.update(0, 1);
    uranus.enableTrail({maxPoints: 1600, color: 0xaaaaaa, trailStep: 500});
    solarSystemGroup.add(uranus.renderedOrbit(0xaaaaaa));

    const neptuneWithMoons = new PlanetMoonSystem(neptune, []);
    solarSystemGroup.add(neptuneWithMoons);
    neptuneWithMoons.update(0, 1);
    neptune.enableTrail({maxPoints: 1600, color: 0x0000ff, trailStep: 500});
    solarSystemGroup.add(neptune.renderedOrbit(0x0000ff));

    const solarSystem = [
        earthMoonSystem,
        noMoonsMercury,
        noMoonsVenus,
        marsWithMoons,
        jupiterWithMoons,
        saturnWithMoons,
        uranusWithMoons,
        neptuneWithMoons
    ];

    const eclipticPlane = new Mesh(
        new RingGeometry(sun.scaledRadius * 1.1, 100, 128),
        new MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0.08, side: DoubleSide, depthWrite: false, visible: false })
    )
    eclipticPlane.rotation.x = Math.PI /2;
    solarSystemGroup.add(eclipticPlane);

    const controlsGui = new ControlsGui();
    document.querySelectorAll("#planetControls button")
        .forEach(button => {
            button.addEventListener("click", () => {
                const body = bodies[button.dataset.body];
                if (body) controlsGui.onSelect(body);
            });
        });

    document.getElementById("farField1").addEventListener("click", () => {
        planetCamera.position.copy(cameraStart.position);
        controlsGui.onReset();
        controls.target.copy(cameraStart.target);
        controls.update();
    });

    document.getElementById("zoomIn").addEventListener("click", () => {
        planetCamera.position.copy(new Vector3(-105, 35, 21));
        controlsGui.onReset();
        controls.target.copy(cameraStart.target);
        controls.update();
    });

    document.getElementById("farField2").addEventListener("click", () => {
        planetCamera.position.copy(new Vector3(0, 700, 0));
        controlsGui.onReset();
        controls.target.copy(cameraStart.target);
        controls.update();
    });

    let tPhys = 0;
    const eclipseIndicator = new LunarEclipseIndicator(earth, luna, earth.equatorialPlane);
    let lastTime = performance.now() * .001;
    function animate(now) {
        const deltaSeconds = (now - lastTime) * .001;
        lastTime = now;

        const dtHours = deltaSeconds * timeScale;
        tPhys += dtHours;
        solarSystem.forEach(body => body.update(tPhys));
        sun.update(tPhys);
        eclipseIndicator.update();
        skyDome.update(now * .001, planetCamera);
        planetRenderer.render(planetaryScene, planetCamera);
        controlsGui.render();
    }

</script>