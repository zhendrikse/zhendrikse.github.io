<style>
    #surfaceCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
    }

    #surface-canvas-container {
        position: relative;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        aspect-ratio: 4 / 5;
    }

    #gui-container {
        margin-top: 0.5em;
        background: #1a1a1a;
    }

    #surface-title {
        text-align: center;
        font-size: clamp(16px, 4vw, 24px);
        font-family: sans-serif;
        color: yellow;
        font-weight: bold;
        text-shadow: 0 0 8px black;
        margin-bottom: 0.5em;
        background: #1a1a1a;
    }

    #surface-equation {
        position: absolute;
        margin-top: 10px;
        width: 100%;
        max-width: 100%;
        font-size: 13px;
        color: yellow;
        text-align: center;
        z-index: 10;
    }

    #surface-equation .mjx-chtml {
        font-size: clamp(12px, 3.5vw, 10px);
        display: block;                 /* make MathJax fill the div */
        max-width: 100%;
        margin: 0 auto;
    }
</style>

<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>

<div id="surface-title"></div>
<div id="surface-equation"></div>
<div id="surface-canvas-container">
    <canvas id="surfaceCanvas"></canvas><br/>
</div>
<div id="gui-container"></div>

<script type="module">
    import * as THREE from "three";
    import { Plot3D, ThreeJsUtils, Axes, AxesParameters, MatlabAxesLayout, MatlabAnnotations }
        from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import { Category, Surface, StandardSurfaceView, MinimalSurfaceView, SurfaceSpecification, TangentFrameView,
        ViewParameters, ColorMapper, ContourType, LiteralStringBasedSurfaceDefinition, SurfaceDefinitions }
        from 'https://www.hendrikse.name/science/js/3d-surface-components.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const canvasContainer = document.getElementById("surface-canvas-container");
    const canvas = document.getElementById("surfaceCanvas");

    class ControlsGui {
        constructor(surface, axes, annotations, ring, viewParameters, onSurfaceSpecificationChanged) {
            this.surface = null;
            this.onSurfaceSpecificationChanged = onSurfaceSpecificationChanged;
            this.viewParameters = viewParameters;
            this.surface = surface;
            this.axes = axes;
            const controls = new GUI({width: 300, autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            this.xFunction = null;
            this.yFunction = null;
            this.zFunction = null;
            this.surfaceCoordinates = {
                x: surface.definition().specification().parametrization.xFn,
                y: surface.definition().specification().parametrization.yFn,
                z: surface.definition().specification().parametrization.zFn
            }

            controls.add(this.viewParameters, 'category', Object.values(Category))
                .name("Category")
                .onChange(value => ring.changeActiveCategoryTo(value));

            //this.#createTangentSpaceFolder(controls);
            this.#createAppearanceFolder(controls, axes, annotations);
            this.#createMathFolder(controls);
            this.updateCurrentSurfaceWith(surface);
        }

        #createTangentSpaceFolder(folder) {
            const tangentFolder = folder.addFolder("Tangent frame");
            // tangentFolder.add(this.viewParameters, 'showTangentFrame')
            //     .name("Tangent frame")
            //     .onChange(value => this.surface.toggleWireframe(value));
            tangentFolder.add(this.viewParameters.tangentFrameParameters, "u", 0, 1, 0.01)
                .name("u-parameter")
                .onChange(value => {
                    tangentFrame.position.set(0, 0, 0);
                    tangentFrame.scale.set(1, 1, 1);
                    tangentFrame.update(this.viewParameters.tangentFrameParameters.u, this.viewParameters.tangentFrameParameters.v);
                    tangentFrame.position.copy(surfaceInAxes.group.position);
                    tangentFrame.scale.set(surfaceInAxes.group.scale.x, surfaceInAxes.group.scale.y, surfaceInAxes.group.scale.z);

                });

            tangentFolder.add(this.viewParameters.tangentFrameParameters, "v", 0, 1, 0.01)
                .name("v-parameter")
                .onChange(value => {
                    tangentFrame.position.set(0, 0, 0);
                    tangentFrame.scale.set(1, 1, 1);
                    tangentFrame.update(this.viewParameters.tangentFrameParameters.u, this.viewParameters.tangentFrameParameters.v);
                    tangentFrame.position.copy(surfaceInAxes.group.position);
                    tangentFrame.scale.set(surfaceInAxes.group.scale.x, surfaceInAxes.group.scale.y, surfaceInAxes.group.scale.z);
                });
            tangentFolder.close();
        }

        #createContourFolder(folder) {
            const contourFolder = folder.addFolder("Contours");
            contourFolder.add(this.viewParameters.contourParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => this.surface.modifyContours({mode: value}));
            contourFolder.add(this.viewParameters.contourParameters, 'color')
                .name("Color")
                .onChange(() => {if (this.#isValidColor()) this.surface.modifyContours(this.viewParameters.contourParameters);});
            contourFolder.add(this.viewParameters.contourParameters, "uCount", 1, 50, 1)
                .name("U contours")
                .onChange(() => this.surface.modifyContours(this.viewParameters.contourParameters));
            contourFolder.add(this.viewParameters.contourParameters, "vCount", 1, 50, 1)
                .name("V contours")
                .onChange(() => this.surface.modifyContours(this.viewParameters.contourParameters));
            contourFolder.close();
        }

        #createSurfaceFolder(folder) {
            const surfaceFolder = folder.addFolder("Surface");
            surfaceFolder.add(this.viewParameters, "colorMode", Object.values(ColorMapper.ColorMode))
                .name("Color Mode")
                .onChange(() => this.surface.changeColorModeTo(this.viewParameters.colorMode));
            surfaceFolder.add(this.viewParameters, 'baseColor')
                .name("Base color")
                .onChange(() => {if (this.#isValidColor()) this.surface.changeBaseColorTo(this.viewParameters.baseColor);});
            surfaceFolder.add(this.viewParameters, "opacity", 0, 1, .01)
                .name("Opacity")
                .onChange(value => this.surface.changeOpacityTo(value));
            surfaceFolder.add(this.viewParameters, "resolution", 10, 200, 1)
                .name("Resolution")
                .onFinishChange(resolution => this.surface.resampleWith(resolution));
            surfaceFolder.add(this.viewParameters, 'wireframe')
                .name("Wireframe")
                .onChange(value => this.surface.toggleWireframe(value));
            surfaceFolder.add(this.viewParameters, 'normals')
                .name('Show Normals')
                .onChange(value => this.#showNormals(this.surface, value));
            surfaceFolder.add(this.viewParameters, 'autoRotate').name('Auto rotate');
            surfaceFolder.close();
        }

        #createAxesFolder(folder, axes, annotations) {
            const axesFolder = folder.addFolder("Axes");
            axesFolder.add(this.viewParameters.axesParameters, 'axesLines')
                .name("Axes").onChange(value => value ? axesLayout.showAxes() : axesLayout.hideAxes());
            axesFolder.add(this.viewParameters.axesParameters, 'axesLabels')
                .name("Axes labels").onChange(value => annotations.visible = value);
            axesFolder.add(this.viewParameters.axesParameters, 'xyPlane') // intentional misuse of xyPlane for all planes
                .name("Grid planes").onChange(value => {
                value ? axesLayout.showXY() : axesLayout.hideXY();
                value ? axesLayout.showXZ() : axesLayout.hideXZ();
                value ? axesLayout.showYZ() : axesLayout.hideYZ();
            });
            axesFolder.close();
        }

        #createMathFolder(folder) {
            const mathFolder = folder.addFolder("Math");

            this.xFunction = mathFolder.add(this.surfaceCoordinates, "x").name("Fx(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification =
                        this.surface.definition().specification().withParametrization({xFn: expr});
                    this.onSurfaceSpecificationChanged(surfaceSpecification);
                });

            this.yFunction = mathFolder.add(this.surfaceCoordinates, "y").name("Fy(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification =
                        this.surface.definition().specification().withParametrization({yFn: expr});
                    this.onSurfaceSpecificationChanged(surfaceSpecification);
                });

            this.zFunction = mathFolder.add(this.surfaceCoordinates, "z").name("Fz(u,v) =")
                .onFinishChange(expr => {
                    const surfaceSpecification =
                        this.surface.definition().specification().withParametrization({zFn: expr});
                    this.onSurfaceSpecificationChanged(surfaceSpecification);
                });

            mathFolder.close();
        }

        #createAppearanceFolder(controls, axes, annotations) {
            const appearanceFolder = controls.addFolder("Appearance");
            this.#createSurfaceFolder(appearanceFolder);
            this.#createAxesFolder(appearanceFolder, axes, annotations);
            this.#createContourFolder(appearanceFolder);

            appearanceFolder.add({reset: () =>
                    plot3D.fitToBoundingBox(this.surface.boundingBox(), {padding: 1.2, translationY: -0.5})}, "reset")
                .name("Reset Camera");
            appearanceFolder.close();
        }

        #isValidColor() {
            const style = new Option().style;
            style.color = this.viewParameters.baseColor;
            return style.color !== '';
        }

        #showNormals(surface, show) {
            if (show) {
                surface.addNormalsWith({});
                surface.changeOpacityTo(0.3);
            } else {
                surface.clearNormals();
                surface.changeOpacityTo(this.viewParameters.opacity);
            }
        }

        #updateSurfaceDataTitleBox() {
            const nameDiv = document.getElementById("surface-title");
            const surfaceData = this.surface.definition().specification();
            nameDiv.textContent = surfaceData.meta.category + ": " + surfaceData.meta.name;

            const equationDiv = document.getElementById("surface-equation");
            equationDiv.innerHTML = "$$\\begin{pmatrix}" +
                surfaceData.parametrization.xFn + " \\\\" +
                surfaceData.parametrization.yFn + " \\\\" +
                surfaceData.parametrization.zFn + "\\end{pmatrix}\\text{, } \\begin{cases} u \\in [" +
                surfaceData.intervals[0][0] + ", " +
                surfaceData.intervals[0][1] + "] \\\\ v \\in [" +
                surfaceData.intervals[1][0] + ", " +
                surfaceData.intervals[1][1] + "] \\end{cases}$$";
            if (window.MathJax) MathJax.typesetPromise([equationDiv]);
        }

        render() {
            if (this.viewParameters.autoRotate)
                this.surface.rotateBy(0.005);
        }

        updateCurrentSurfaceWith= (newSurface) => {
            this.surface = newSurface;
            this.#updateSurfaceDataTitleBox();
            const surfaceSpecification = this.surface.definition().specification();
            this.xFunction.setValue(surfaceSpecification.parametrization.xFn);
            this.yFunction.setValue(surfaceSpecification.parametrization.yFn);
            this.zFunction.setValue(surfaceSpecification.parametrization.zFn);
        }
    }

    class Ring {
        constructor(parentGroup, boundingBox, {
            ringRadius = 2,
            verticalOffset = -1,
            activeCategory = Category.MISC,
            rotationSpeed=0.01,
            selectionLerp=0.08
        } = {}) {
            this.group = new THREE.Group();
            parentGroup.add(this.group);
            this.surfaces = [];
            this.boundingBox = boundingBox;
            this.ringRadius = ringRadius;
            this.activeCategory = activeCategory;
            this.rotationSpeed = rotationSpeed;
            this.selectionLerp = selectionLerp;
            this.verticalOffset = verticalOffset;
            this.ringTargetRotation = null;
            this.selectedSurface = null;
        }

        #onSelectedSurface(selectedRingSurface) {
            this.#setTargetRotation(selectedRingSurface);
            if (this.selectedSurface) this.selectedSurface.onDeselect();
            selectedRingSurface.onSelect();
            this.selectedSurface = selectedRingSurface;
        }

        #placeAndShowSurface = (surface, index) => {
            const angle = 2 * Math.PI * index / this.visibleRingItems().length;
            const position = new THREE.Vector3(this.ringRadius * Math.cos(angle), this.verticalOffset, this.ringRadius * Math.sin(angle));
            surface.moveTo(position);
            surface.show();
        };

        #redistribute() {
            this.surfaces.forEach(surface => surface.hide());
            this.visibleRingItems().forEach((surface, index) => this.#placeAndShowSurface(surface, index));
        }

        #rotate() {
            const delta = this.ringTargetRotation - this.group.rotation.y;
            const shortest = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            this.group.rotation.y += shortest * this.selectionLerp;

            if (Math.abs(shortest) < 0.001) {
                this.group.rotation.y = this.ringTargetRotation;
                this.ringTargetRotation = null;
            }
        }

        #rotateRingToSelectedSurface = () => { if (this.#rotationToTargetSurfaceIsNeeded()) this.#rotate(); };
        #rotateSurfaces = () => this.visibleRingItems().forEach(surface => surface.rotateBy(this.rotationSpeed));
        #rotationToTargetSurfaceIsNeeded = () => this.ringTargetRotation !== null;

        #setTargetRotation(selectedSurface) {
            const local = selectedSurface.position();
            const angle = Math.atan2(local.x, local.z);
            this.ringTargetRotation = -angle + Math.PI * .45;
        }

        add(surfaces) {
            surfaces.forEach(surfaceDataAsString => {
                const surfaceSpecification = new SurfaceSpecification(surfaceDataAsString);
                const surfaceDefinition = new LiteralStringBasedSurfaceDefinition(surfaceSpecification);
                const selectorSurface = new MinimalSurfaceView(this.group, new Surface(surfaceDefinition), {});
                ThreeJsUtils.fitGroupToBox(
                    selectorSurface.group,
                    selectorSurface.boundingBox(),
                    boundingBox,
                    {alignY: "min", padding: 1.1}
                );
                this.surfaces.push(selectorSurface);
            });
            this.#redistribute();
        }

        changeActiveCategoryTo(category) {
            this.activeCategory = category;
            this.#redistribute();
        }

        findSurfaceByName = (name) => this.surfaces.find(surface => surface.definition().specification().meta.name === name);
        findSurfaceByMesh = (mesh) => this.surfaces.find(surface => surface.selectableObject() === mesh);
        render = () => { this.#rotateRingToSelectedSurface(); this.#rotateSurfaces(); }
        selectableObjects = () => this.visibleRingItems().map(surface => surface.selectableObject());
        onSelectTo = (selectedRingSurface) => this.#onSelectedSurface(selectedRingSurface);
        visibleRingItems = () => this.surfaces.filter(surface => surface.definition().specification().meta.category === this.activeCategory);
    }

    let tangentFrame = null;
    let surfaceInAxes = null;
    function displayedSurface(surfaceSpecification, visualizationParameters, axes) {
        const surfaceDefinition = new LiteralStringBasedSurfaceDefinition(surfaceSpecification);
        const newSurface = new StandardSurfaceView(worldGroup, new Surface(surfaceDefinition), visualizationParameters);

        // visualizationParameters.tangentFrameParameters.scale = newSurface.boundingBox().max.length() * .4;
        // tangentFrame = new TangentFrameView(surfaceDefinition, visualizationParameters.tangentFrameParameters);
        // newSurface.group.add(tangentFrame);

        ThreeJsUtils.fitGroupToBox(
            newSurface.group,
            newSurface.boundingBox(),
            axes.boundingBox(),
            { alignY: "min", padding: 1.1 }
        );
        return newSurface;
    }

    const surfacePlotScene = new THREE.Scene();
    surfacePlotScene.background = new THREE.Color(0x131313);
    const worldGroup = new THREE.Group();
    surfacePlotScene.add(worldGroup);

    // Axes
    const axes = new Axes();
    worldGroup.add(axes);
    const axesLayout = new MatlabAxesLayout(4.2, 10);
    const annotations = new MatlabAnnotations(canvasContainer, axesLayout);
    axes.setLayout(axesLayout);
    axes.setAnnotations(annotations);

    // Surface
    const plot3D = new Plot3D(canvas, surfacePlotScene, axes);
    const bbox = new THREE.Box3();
    bbox.setFromObject( worldGroup );
    plot3D.fitToBoundingBox(bbox, {padding: 1.2, translationY: -3.0});

    const surfaceData = SurfaceDefinitions[20];
    const visualizationParameters = new ViewParameters({axesParameters: new AxesParameters({axesLabels: false})});
    annotations.visible = visualizationParameters.axesParameters.axesLabels;
    surfaceInAxes = displayedSurface(new SurfaceSpecification(surfaceData), visualizationParameters, axes);

    // Ring
    const boundingBox = surfaceInAxes.boundingBox();
    ThreeJsUtils.scaleBox3(boundingBox, 0.20);
    const ring = new Ring(worldGroup, surfaceInAxes, boundingBox);
    ring.add(SurfaceDefinitions);
    ring.changeActiveCategoryTo(surfaceData.meta.category);
    const selectedRingSurface = ring.findSurfaceByName(surfaceData.meta.name);
    ring.onSelectTo(selectedRingSurface);

    // Interaction
    const controlsGui = new ControlsGui(surfaceInAxes, axes, annotations, ring, visualizationParameters,
        (newSpec) => {
            surfaceInAxes.dispose();
            surfaceInAxes = displayedSurface(newSpec, visualizationParameters, axes);
            controlsGui.updateCurrentSurfaceWith(surfaceInAxes);
        });
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    canvas.addEventListener("pointerdown", event => {
        mouse.x = (event.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.offsetY / canvas.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, plot3D.camera);

        const hits = raycaster.intersectObjects(
            ring.selectableObjects(),
            false // IMPORTANT: no recursion
        );

        if (!hits.length) return;

        const selectedMesh = hits[0].object;
        const selectedRingSurface = ring.findSurfaceByMesh(selectedMesh);
        surfaceInAxes.dispose();
        surfaceInAxes = displayedSurface(selectedRingSurface.definition().specification(), visualizationParameters, axes);
        ring.onSelectTo(selectedRingSurface);
        controlsGui.updateCurrentSurfaceWith(surfaceInAxes);
    });

    function animate() {
        requestAnimationFrame(animate);
        plot3D.render();
        ring.render();
        controlsGui.render();
    }
    animate();
</script>
