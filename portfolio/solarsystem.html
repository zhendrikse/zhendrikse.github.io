<script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
</script>

<div id="planetControls">
    <table>
        <tr>
            <td><button data-body="sun">ðŸŒž&nbsp;Sun</button></td>
            <td><button data-body="mercury">Mercury</button></td>
            <td><button data-body="venus">Venus</button></td>
            <td><button data-body="earth">Earth</button></td>
            <td><button data-body="mars">Mars</button></td>
        </tr>
    </table>
    <canvas class="applicationCanvas" id="planetsCanvas" style="aspect-ratio: 19 / 12;"></canvas>
    <table>
        <tr>
            <td> <button id="resetCamera">ðŸ”„&nbsp;Reset</button></td>
            <td><button data-body="jupiter">Jupiter</button></td>
            <td><button data-body="saturn">Saturn</button></td>
            <td><button data-body="uranus">Uranus</button></td>
            <td><button data-body="neptune">Neptune</button></td>
        </tr>
    </table>
</div>
<div class="guiContainer" id="solarSystemGui"></div>

<script type="module">
    import { Group, Box3, SphereGeometry, MeshPhongMaterial, Mesh, TextureLoader, Color, ShaderMaterial,
        Scene, PerspectiveCamera, Vector3, WebGLRenderer, AmbientLight, PointLight, BackSide, AdditiveBlending,
        DoubleSide, Quaternion, BufferGeometry, BufferAttribute, SRGBColorSpace, ACESFilmicToneMapping,
        MeshBasicMaterial, LinearSRGBColorSpace, NoToneMapping, FrontSide} from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { ThreeJsUtils, SkyDome, Trail } from 'https://www.hendrikse.name/science/js/three-js-extensions.js';
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const planetsCanvas = document.getElementById('planetsCanvas');
    planetsCanvas.focus();
    console.clear();

    const textureLoader = new TextureLoader();
    textureLoader.setCrossOrigin("anonymous");

    let dt = 1;

    const AU = 1.496 * 1E11;   // astronomical unit
    const EARTH_SEMI_MAJOR_AXIS = 149598261.;

    const PLANET_SCALE = 0.25E7;  // meters â†’ render units (radius), planet sizes are shrunk by this factor
    const SUN_SCALE = 100 * PLANET_SCALE;
    const ORBIT_SCALE  = 40;    // additional orbit compression factor for nice visual representation
    const DISTANCE_SCALE = AU / ORBIT_SCALE;
    const SCALE_MOON = 275 ; // scaling factor for semi major axes of some moons
    const toRenderUnits = (vector) => vector.clone().multiplyScalar(1000 / DISTANCE_SCALE);

    const planetaryScene = new Scene();
    // --- CAMERA ---
    const cameraStart = {
        position: new Vector3(-60, 24, 12),
        target: new Vector3(0, 0, 0)
    };
    const planetCamera = new PerspectiveCamera(50, 1, .1, 5000);
    planetCamera.position.copy(cameraStart.position);

    const planetRenderer = new WebGLRenderer( {antialias: true, canvas: planetsCanvas, alpha: true} );
    planetRenderer.shadowMap.enabled = false;
    planetRenderer.setAnimationLoop( animate );
    planetRenderer.toneMapping = ACESFilmicToneMapping;
    planetRenderer.toneMappingExposure = 1.5;
    planetRenderer.outputColorSpace = SRGBColorSpace;


    // Resizing for mobile devices
    ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    window.addEventListener('resize', () => {
        ThreeJsUtils.resizeRendererToCanvas(planetRenderer, planetCamera);
    });

    const controls = new OrbitControls(planetCamera, planetsCanvas);
    controls.target.copy(cameraStart.target);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const skyDome = new SkyDome({starDensity: 1, skyRadius: 4950, glowStarCount: 500});
    planetaryScene.add(skyDome);

    // Abstract base class for celestial bodies, hence should _not_ be instantiated directly!
    const TEXTURES_PATH = "https://www.hendrikse.name/science/astrophysics/code/textures/";
    //const TEXTURES_PATH = "textures/";
    class CelestialBody extends Group {
        constructor(bodyData, scale, {bumpScale=0.005, identicalBumpMap=false, orbitPointsCount=10000} = {}) {
            super();
            this._orbitPointsCount = orbitPointsCount;
            this._name = bodyData.name;
            this._radius = bodyData.radius;
            this._mass = bodyData.mass;
            this._tilt = bodyData.tilt;
            this._timescale = 1;
            this._spin = bodyData.spin;

            this._geometry = new SphereGeometry(bodyData.radius / scale, 64, 64);
            this._body = new Mesh(this._geometry, this._material(bumpScale, identicalBumpMap));
            this.add(this._body);
            this._body.castShadow = true;
            this._body.receiveShadow = false;

            this._coordinates = [];
            this._trail = new Trail(this);
        }

        get tilt() { return this._tilt; }
        get radius() { return this._radius; }
        get mass() { return this._mass; }

        _orbitIndex(t) { return Math.floor(t / this._timescale) % this._coordinates.length; }

        _linSpace(start, stop, num) {
            const result = [];
            const step = (stop - start) / (num - 1);

            for (let i = 0; i < num - 1; i++)
                result.push(start + i * step);

            result.push(stop); // include last point as well
            return result;
        }

        // Newton-Raphson to calculate elliptic orbit
        _orbit(meanAnomaly, eccentricity, a, inclination, ascension, acc=1.e-2) {
            // nPoints = number of orbit coordinates generated (affects temporal accuracy - dt(real)=365.25*86400/n (in seconds))
            const nPoints = this._orbitPointsCount;
            const range = this._linSpace(meanAnomaly, 2 * Math.PI + meanAnomaly, nPoints);

            let eccAnom = range.slice();
            let eccAnomOld = new Array(nPoints);

            let maxDiff = Infinity;

            while (maxDiff > acc) {
                maxDiff = 0;
                eccAnomOld = eccAnom.slice(); // copy array

                // Newtonâ€“Raphson step
                for (let i = 0; i < nPoints; i++) {
                    const f = eccAnomOld[i] - eccentricity * Math.sin(eccAnomOld[i]) - range[i];
                    const fPrime = 1 - eccentricity * Math.cos(eccAnomOld[i]);
                    eccAnom[i] = eccAnomOld[i] - f / fPrime;
                    maxDiff = Math.max(maxDiff, Math.abs(eccAnom[i] - eccAnomOld[i]));
                }
            }

            const points = [];
            for (let i = 0; i < nPoints; i++) {
                const theta = 2 * Math.atan2(
                    Math.sqrt(1 + eccentricity) * Math.sin(eccAnom[i] / 2),
                    Math.sqrt(1 - eccentricity) * Math.cos(eccAnom[i] / 2)
                );

                const r = a * (1 - eccentricity * Math.cos(eccAnom[i]));
                const thetaAsc = theta - ascension;

                const x = (Math.cos(ascension) * Math.cos(thetaAsc) -
                    Math.sin(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const z = (Math.sin(ascension) * Math.cos(thetaAsc) +
                    Math.cos(ascension) *
                    Math.sin(thetaAsc) *
                    Math.cos(inclination));

                const y = Math.sin(theta - ascension) * Math.sin(inclination);

                points.push(new Vector3(x, y, z).multiplyScalar(r));
            }

            return points;
        }

        _material(bumpScale, identicalBumpMap) { throw new Error("Abstract class: implement material!"); }

        updateRotation(t) {
            // 1. tilt-quaternion (rotation of XZ plane â†’ real axis)
            const tiltQuaternion = new Quaternion();
            tiltQuaternion.setFromAxisAngle(new Vector3(0, 0, 1), this._tilt);

            // 2. spin-quaternion around local Y
            const spinQuaternion = new Quaternion();
            spinQuaternion.setFromAxisAngle(new Vector3(0, 1, 0), this._spin * t);

            // 3. combine tilt + spin
            this.quaternion.copy(tiltQuaternion).multiply(spinQuaternion);
        }

        enableTrail({ maxPoints=1000, color=0xffff00, lineWidth=1 } = {}) {
            this._trail.enable({maxPoints, color, lineWidth});
        }

        updateTrail(dt) { this._trail.update(dt); }
        disposeTrail() { this._trail.dispose(); }
    }

    class Planet extends CelestialBody {
        constructor(planetData, {bumpScale=0.005, identicalBumpMap=false} = {}) {
            super(planetData, PLANET_SCALE, {bumpScale: bumpScale, identicalBumpMap: identicalBumpMap});
            this._timescale = (planetData.a / EARTH_SEMI_MAJOR_AXIS) ** 1.5; // rotation period w.r.t. Earth
            this._body.castShadow = true;
            this._body.receiveShadow = false;

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        _material(bumpScale, identicalBumpMap) {
            const bumpMap = TEXTURES_PATH + this._name + (identicalBumpMap ? "map.jpg" : "bump.jpg");
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}` + this._name + "map.jpg"),
                bumpMap: textureLoader.load(bumpMap),
                bumpScale: bumpScale,
                shininess: 0
            });
        }

        update(t, dt) {
            this.updateTrail(dt);
            this.updateRotation(t);
        }
    }

    class Satellite extends CelestialBody {
        constructor(moonData, planet, scale) {
            super(moonData, scale);
            this._planet = planet;
            this._angle = 0;
            this._a = moonData.a; // semi-major axis
            this._e = moonData.e;

            this._timescale = moonData.period / 365.25;  // rotation period w.r.t Earth
            this._lock = moonData.tidal_lock;
            this._body.castShadow = false;
            this._body.receiveShadow = true;

            this._coordinates = this._orbit(
                moonData.mean_anomaly,
                this._e,
                this._a,
                planet.tilt +
                moonData.inclination,
                moonData.right_ascension);  // create orbit coordinates list for the moon

            this.#centerMoonsOrbitAroundOrigin();
        }

        #centerMoonsOrbitAroundOrigin() {
            const center = new Vector3();
            this._coordinates.forEach(position => center.add(position));
            center.divideScalar(this._coordinates.length);
            this._coordinates.forEach(position => position.sub(center));
        }

        update(t, dt) {
            this.updateTrail(dt);
            if (this._lock) {
                const planetWorldPos = this._planet.getWorldPosition(new Vector3());
                this.lookAt(planetWorldPos);
                // Correct fixed phase fase-offset if needed (texture-orientation)
                this.rotateY(Math.PI); // of rotateZ, afhankelijk van je texture
            } else
                this.updateRotation(t); // gewone spin
        }
    }

    class PlanetMoonSystem extends Group {
        constructor(planet, moons = []) {
            super();
            this._planet = planet;
            this._moons = moons;

            this.add(planet);
            moons.forEach(moon => this.add(moon));

            this._coordinates = planet._coordinates;
        }

        get mass() {
            let M = this._planet.mass;
            for (const moon of this._moons)
                M += moon.mass;
            return M;
        }

        update(t, dt) {
            // 1. barycentric position (sun-centric)
            const baryPosition = this._coordinates[this._planet._orbitIndex(t)].clone();

            // 2. total mass
            const M = this.mass;

            // 3. barycentric correction
            const correction = new Vector3();
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                correction.add(r.clone().multiplyScalar(moon.mass / M));
            }

            // 4. planet position
            this._planet.position.copy(toRenderUnits(baryPosition.clone().sub(correction)));

            // 5. moon positions
            for (const moon of this._moons) {
                const r = moon._coordinates[moon._orbitIndex(t)];
                moon.position.copy(toRenderUnits(baryPosition.clone().add(r)));
            }

            // 6. rotations
            this._planet.update(t, dt);
            for (const moon of this._moons)
                moon.update(t, dt);
        }
    }

    class Sun extends CelestialBody {
        constructor(bodyData) {
            super(bodyData, SUN_SCALE);

            this._body.castShadow = false;
            this._body.receiveShadow = false;

            // ðŸŒž inner glow (FrontSide, harsher, brighter)/
            const innerGlowMaterial = this._createAtmosphereMaterial(true, false, 0xfffa00, 0.3, 2.0);
            innerGlowMaterial.side = FrontSide;
            const innerGlow = new Mesh(this._geometry.clone(), innerGlowMaterial);
            innerGlow.scale.multiplyScalar(1.01);
            innerGlow.material.blending = AdditiveBlending;

            // ðŸŒž outer glow (BackSide, softer, bigger)
            const outerGlowMaterial = this._createAtmosphereMaterial(false, false, 0xfffa00, 0.3, 4.0);
            outerGlowMaterial.side = BackSide;
            const outerGlow = new Mesh(this._geometry.clone(), outerGlowMaterial);
            outerGlow.scale.multiplyScalar(1.2);

            this.add(innerGlow, outerGlow);
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshBasicMaterial({map: textureLoader.load(`${TEXTURES_PATH}` + "sunmap.jpg")})
        }

        _createAtmosphereMaterial(depthTest=true, depthWrite=false, glowColor = 0xffff00, coef = 0.5, power = 2.0) {
            return new ShaderMaterial({
                uniforms: {
                    glowColor: { value: new Color(glowColor) },
                    coeficient: { value: coef },
                    power: { value: power }
                },
                vertexShader: `
            varying vec3 vVertexWorldPosition;
            varying vec3 vVertexNormal;

            void main() {
                vVertexNormal = normalize(normalMatrix * normal);
                vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
                fragmentShader: `
            uniform vec3 glowColor;
            uniform float coeficient;
            uniform float power;
            varying vec3 vVertexNormal;
            varying vec3 vVertexWorldPosition;
            void main() {
                vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;
                vec3 viewCameraToVertex = (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
                viewCameraToVertex = normalize(viewCameraToVertex);
                float intensity = pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);
                intensity = clamp(intensity, 0.0, 0.5); // maximaal 0.5 voor subtiele halo
                gl_FragColor = vec4(glowColor, intensity);
            }
        `,
                transparent: true,
                depthWrite: depthWrite,
                depthTest: depthTest
            });
        }
    }

    class Moon extends Satellite {
        constructor(moonData, planet) {
            super(moonData, planet, PLANET_SCALE);
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}moonmap1k.jpg`),
                bumpMap: textureLoader.load(`${TEXTURES_PATH}moonbump1k.jpg`),
                bumpScale: 0.002,
                emissiveIntensity: 0.1,
                shininess: 0
            });
        }
    }

    class Earth extends Planet {
        constructor(planetData) {
            super(planetData);
            this._name = planetData.name;
            this._timescale = 1; // rotation period w.r.t. Earth

            // create orbit coordinates list for the planet
            this._coordinates = this._orbit(
                planetData.mean_anomaly,
                planetData.e,
                planetData.a,
                planetData.inclination,
                planetData.right_ascension
            );
        }

        _material(bumpScale, identicalBumpMap) {
            return new MeshPhongMaterial({
                map: textureLoader.load(`${TEXTURES_PATH}earthmap1k.jpg`),
                bumpMap: textureLoader.load(`${TEXTURES_PATH}earthbump1k.jpg`),
                bumpScale: 0.05,
                specularMap: textureLoader.load(`${TEXTURES_PATH}earthspec1k.jpg`),
                specular: new Color(0x333333),
                emissive: new Color(0x112244),
                emissiveIntensity: 0.05,
                shininess: 3
            });
        }
    }

    // Port to new Three.js from https://github.com/jeromeetienne/threex.planets/blob/master/threex.planets.js
    const PlanetRingGeometry = function (innerRadius, outerRadius, thetaSegments) {

        innerRadius   = innerRadius || 0;
        outerRadius   = outerRadius || 1;
        thetaSegments = Math.max(3, Math.floor(thetaSegments || 8));

        // number of vertices = 4 per segment
        const vertexCount = thetaSegments * 4;
        const positionArray = new Float32Array(vertexCount * 3);
        const normalArray   = new Float32Array(vertexCount * 3);
        const uvArray       = new Float32Array(vertexCount * 2);
        const indexArray    = new Uint16Array(thetaSegments * 6);

        let pPos = 0, pNorm = 0, pUV = 0, pIdx = 0;
        let vertexIndex = 0;

        for (let i = 0; i < thetaSegments; i++) {

            const angleLo = (i / thetaSegments) * Math.PI * 2;
            const angleHi = ((i + 1) / thetaSegments) * Math.PI * 2;

            // calculate positions
            const x1 = Math.cos(angleLo), y1 = Math.sin(angleLo);
            const x2 = Math.cos(angleHi), y2 = Math.sin(angleHi);

            // 4 vertices per ring segment
            const positions = [
                innerRadius * x1, innerRadius * y1, 0,
                outerRadius * x1, outerRadius * y1, 0,
                innerRadius * x2, innerRadius * y2, 0,
                outerRadius * x2, outerRadius * y2, 0,
            ];

            // normals (all Z = +1)
            const normals = [
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
            ];

            // UVs as in original code
            const uvs = [
                0, 0,
                1, 0,
                0, 1,
                1, 1,
            ];

            // Fill buffers
            for (let j = 0; j < 4; j++) {
                positionArray[pPos++] = positions[j * 3 + 0];
                positionArray[pPos++] = positions[j * 3 + 1];
                positionArray[pPos++] = positions[j * 3 + 2];

                normalArray[pNorm++]   = normals[j * 3 + 0];
                normalArray[pNorm++]   = normals[j * 3 + 1];
                normalArray[pNorm++]   = normals[j * 3 + 2];

                uvArray[pUV++] = uvs[j * 2 + 0];
                uvArray[pUV++] = uvs[j * 2 + 1];
            }

            // indices (2 triangles)
            indexArray[pIdx++] = vertexIndex + 0;
            indexArray[pIdx++] = vertexIndex + 1;
            indexArray[pIdx++] = vertexIndex + 2;

            indexArray[pIdx++] = vertexIndex + 2;
            indexArray[pIdx++] = vertexIndex + 1;
            indexArray[pIdx++] = vertexIndex + 3;

            vertexIndex += 4;
        }

        // Create geometry
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', new BufferAttribute(positionArray, 3));
        geometry.setAttribute('normal',   new BufferAttribute(normalArray, 3));
        geometry.setAttribute('uv',       new BufferAttribute(uvArray, 2));
        geometry.setIndex(new BufferAttribute(indexArray, 1));
        geometry.computeBoundingSphere();

        return geometry;
    };

    class Saturn extends Planet {
        constructor(planetData) {
            super(planetData, {bumpScale: 0.05, identicalBumpMap: true});

            const innerRingRadius = 1.11 * planetData.radius;
            const outerRingRadius = 2.1 * planetData.radius;
            const ringMesh = this.#createRings(
                innerRingRadius / PLANET_SCALE,
                outerRingRadius / PLANET_SCALE);
            this.add(ringMesh);
        }

        #createRings(innerRadius, outerRadius) {
            const geometry = new PlanetRingGeometry(innerRadius, outerRadius, 128);
            const texture = new TextureLoader().load(`${TEXTURES_PATH}saturnringcolor.jpg`);
            const material = new MeshPhongMaterial({
                map: texture,
                side: DoubleSide,
                transparent: true,
                opacity: 0.85
            });

            const rings = new Mesh(geometry, material);
            rings.rotation.x = Math.PI / 2; // Ring lies in XY plane â†’ tilt to XZ
            this.rotation.z = this._tilt; // Axial tilt (set only once!)
            return rings;
        }
    }

    class Uranus extends Planet {
        constructor(planetData) {
            super(planetData, {identicalBumpMap: true, bumpScale: 0.05});

            const inner = 1.5 * planetData.radius / PLANET_SCALE;
            const outer = 1.8 * planetData.radius / PLANET_SCALE;

            const geometry = new PlanetRingGeometry(inner, outer, 128);
            const texture = new TextureLoader().load(`${TEXTURES_PATH}uranusringcolour.jpg`);

            const material = new MeshPhongMaterial({
                map: texture,
                side: DoubleSide,
                transparent: true,
                opacity: 0.5,          // subtle
                depthWrite: false       // prevent z-fighting
            });

            const rings = new Mesh(geometry, material);

            rings.rotation.x = Math.PI / 2;
            this.rotation.z = this._tilt; // Uranus ~98Â°

            this.add(rings);
        }
    }

    class ControlsGui {
        constructor() {
            const controls = new GUI({width: "100%", autoPlace: false});
            document.getElementById("solarSystemGui").appendChild(controls.domElement);
            this._activeFocus = null;


            const settings = {
                dt: 1
            };

            controls.add(settings, 'dt', 0.01, 10, 0.01).name("Time Step (dt)").onChange(value => {
                dt = value;
            });
        }

        focusOnObject(object, {
            distanceFactor = 2.5,
            duration = 1.2
        } = {}) {
            const startTime = performance.now();
            const startCamPos = planetCamera.position.clone();
            const startTarget = controls.target.clone();

            // Determine center and size
            const box = new Box3().setFromObject(object);
            ThreeJsUtils.scaleBox3(box, 0.9);
            const center = new Vector3();
            const size = new Vector3();
            box.getCenter(center);
            box.getSize(size);

            const radius = size.length() * 0.5;
            const currentViewDirection = new Vector3()
                .subVectors(startCamPos, startTarget)
                .normalize();

            const endCamPos = center
                .clone()
                .add(currentViewDirection
                    .multiplyScalar(radius * distanceFactor));

            this._activeFocus = () => {
                const time = (performance.now() - startTime) / (duration * 1000);
                const k = Math.min(time, 1);
                const step = k * k * (3 - 2 * k); // smoothstep

                planetCamera.position.lerpVectors(startCamPos, endCamPos, step);
                controls.target.lerpVectors(startTarget, center, step);
                controls.update();

                if (k >= 1) this._activeFocus = null;
            };
        }

        render() {
            if (this._activeFocus) this._activeFocus();
        }
    }

    const solarSystemGroup = new Group();
    planetaryScene.add(solarSystemGroup);

    const sun = new Sun({
        "radius": 696300000.0,
        "mass": 1.9885440000000002e+30,
        "spin": 3600 * 2.8653290845717256e-06,
        "tilt": 0.1265363707695889
    });
    sun.position.set(0, 0, 0);
    solarSystemGroup.add(sun);
    const sunLight = new PointLight(0xffffff, 2, 0, .1); // intense, no max distance
    sunLight.position.set(0, 0, 0);
    planetaryScene.add(sunLight);

    const earth = new Earth({
        "name": "earth",
        "a": EARTH_SEMI_MAJOR_AXIS,
        "e": 0.01671123,
        "inclination": 0.,
        "right_ascension": 0.,
        "mean_anomaly": 6.2398515744,
        "radius": 6371010, // meters
        "mass": 5.97219e+24,
        "spin": 2 * Math.PI / 24.,
        "tilt": 23 * Math.PI / 180
    });
    const mercury = new Planet({
        "name": "mercury",
        'a': 57909050.,
        'e': 0.205630,
        'inclination': 7 * Math.PI / 180.,
        'right_ascension': 0.8436854966,
        'mean_anomaly': 3.0507657193,
        'radius': 2439.7 * 1e3,
        "mass": 3.302e+23,
        'tilt': 0.1 * Math.PI / 180.,
        "spin": 2 * Math.PI / 4222.6
    }, {bumpScale: 0.005});
    const venus = new Planet({
        "name": "venus",
        'a': 108208000.,
        'e': 0.0067,
        'inclination': 3.39 * Math.PI / 180.,
        'right_ascension': 1.3381895772,
        'mean_anomaly': 0.8746717546,
        'radius': 6051.8 * 1e3,
        "mass": 4.8685e+23,
        'tilt': 177 * Math.PI / 180.,
        'spin':  -2 * Math.PI / 2802.
    }, {bumpScale: 0.005});
    const mars = new Planet({
        "name": "mars",
        'a': 227939100.,
        'e': 0.093315,
        'inclination': 1.85 * Math.PI / 180.,
        'right_ascension': 0.8676591934,
        'mean_anomaly': 0.3378329113,
        'radius': 3393.5 * 1e3,
        "mass": 6.4185e+23,
        'tilt': 25 * Math.PI / 180.,
        'spin': 2 * Math.PI / 24.66
    }, {bumpScale: 0.05});
    const jupiter = new Planet({
        "name": "jupiter",
        'a': 778547200.,
        'e': 0.048775,
        'inclination': 1.31 * Math.PI / 180.,
        'right_ascension': 1.7504400393,
        'mean_anomaly': 0.3284360586,
        'radius': 71400. * 1e3,
        "mass": 1.89813e+27,
        'tilt': 3 * Math.PI / 180.,
        'spin': 2 * Math.PI / 9.93
    }, {bumpScale: 0.02, identicalBumpMap: true});
    const saturn = new Saturn({
        "name": "saturn",
        'a': 1433449370.,
        'e': 0.055723219,
        'inclination': 2.49 * Math.PI / 180.,
        'right_ascension': 1.98,
        'mean_anomaly': 5.5911055356,
        'radius': 60000. * 1e3,
        "mass": 5.68319e+26,
        'tilt': 27 * Math.PI / 180.,
        'spin': 2 * Math.PI / 10.66 }, {identicalBumpMap: true, bumpScale: 0.05});
    const uranus = new Uranus({
        "name": "uranus",
        'a': 2876679082.,
        'e': 0.044405586,
        'inclination': 0.77 * Math.PI / 180.,
        'right_ascension': 1.2908891856,
        'mean_anomaly': 2.4950479462,
        'radius': 25600. * 1E3,
        "mass": 8.68103E25,
        'tilt': 98 * Math.PI / 180.,
        'spin': -2 * Math.PI / 17.24});
    const neptune = new Planet({
        'name': "neptune",
        'a': 4503443661.,
        'e': 0.011214269,
        'inclination': 1.77 * Math.PI / 180.,
        'right_ascension': 2.3001058656,
        'mean_anomaly': 4.6734206826,
        'radius': 24300. * 1E3,
        "mass": 1.024E26,
        'tilt': 30 * Math.PI / 180.,
        'spin': 2 * Math.PI / 16.11,
    }, {identicalBumpMap: true, bumpScale: 0.05});

    const luna = new Moon({
        "name": "luna",
        "a": 384399 * 50.,
        "e": 0.0549,
        "inclination": (-23.4 + 5.145) * Math.PI / 180.,
        "right_ascension": -Math.PI / 2.,
        "mean_anomaly": 0.,
        "radius": 1737400,
        "mass": 7.349e+22,  // kg
        "spin": 2 * Math.PI / 708.7341666667,
        "tilt": 0.11641346110802178, // rad
        'period': 27.321, // days
        "tidal_lock": true
    }, earth);
    const phobos = new Moon({
        "name": "phobos",
        'a': 9376 * 1000,
        'e': 0.0151,
        'inclination': 0,
        'right_ascension': -Math.PI / 2,
        'mean_anomaly': 0.,
        'radius': 11.2667 * 1E4,
        "mass": 1.06E16,
        'tilt': 0.,
        'spin': 0,
        'period': 0.31891023,
        'tidal_lock': 1}, mars);
    const deimos = new Moon({
        'name': "deimos",
        'a': 23463.2 * 650.,
        'e': 0.00033,
        'inclination': 0,
        'right_ascension': -Math.PI / 2,
        'mean_anomaly': 0.,
        'radius': 10. * 1E4,
        "mass": 1.5E15,
        'tilt': 0.,
        'spin': 0,
        'period': 1.263,
        'tidal_lock': 1}, mars);
    const callisto = new Moon({
        'name': "callisto",
        'a': 1882700 * SCALE_MOON / 2,
        'e': 0.0074,
        'inclination': 0.003351032164,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 2410.3 * 1e3,
        "mass": 1.076E23,
        'tilt': 0.,
        'spin': 0,
        'period': 16.689,
        'tidal_lock': 1}, jupiter);
    const europa = new Moon({
        'name': "europa",
        'a': 670900 * SCALE_MOON,
        'e': 0.009,
        'inclination': 0.008203047484,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 1560.8 * 1e3,
        "mass": 4.8E22,
        'tilt': 0.,
        'spin': 0,
        'period': 12.689,
        'tidal_lock': 1}, jupiter);
    const ganymede = new Moon({
        'name': "ganymede",
        'a': 1070400 * SCALE_MOON,
        'e': 0.0013,
        'inclination': 0.003490658504,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 2634.1 * 1E3,
        "mass": 1.4819E23,
        'tilt': 0.,
        'spin': 0,
        'period': 10.689,
        'tidal_lock': 1}, jupiter);
    const io = new Moon({
        'name': "io",
        'a': 421800 * SCALE_MOON * 1.5,
        'e': 0.0041,
        'inclination': 0.03857177647,
        'right_ascension': 0.,
        'mean_anomaly': 0.,
        'radius': 1821.6 * 1E3,
        "mass": 8.9319E22,
        'tilt': 0.,
        'spin': 0,
        'period': 6.689,
        'tidal_lock': 1
    }, jupiter);
    const dione = new Moon({
        'name': "dione",
        'a': 377396 * 3 * SCALE_MOON,
        'e': 0.0022,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 561.4 * 3 * 1e3,
        "mass": 1.095E21,
        'tilt': 0.,
        'spin': 0,
        'period': 7.689,
        'tidal_lock': 1
    }, saturn);
    const enceladus = new Moon({
        'a': 237948 * 3 * SCALE_MOON,
        'planet_name': "saturn",
        'e': 0.0047,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 252.1 * 3 * 1e3,
        "mass": 1.08022E20,
        'tilt': 0.,
        'spin': 0,
        'period': 16.689,
        'tidal_lock': 1
    }, saturn);
    const tethys = new Moon({
        'name': "tethys",
        'a': 294619 * 3 * SCALE_MOON,
        'e': 0.,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 531.1 * 3 * 1e3,
        "mass": 6.17E20,
        'tilt': 0.,
        'spin': 0,
        'period': 1.689,
        'tidal_lock': 1
    }, saturn);
    const titan = new Moon({
        'name': "titan",
        'a': 1221870 * SCALE_MOON,
        'e': 0.0288,
        'inclination': 0,
        'right_ascension': -Math.PI / 2.,
        'mean_anomaly': 0.,
        'radius': 2576. * 1E3,
        "mass": 1.345E23,
        'tilt': 0.,
        'spin': 0,
        'period': 61.689,
        'tidal_lock': 1
    }, saturn);

    const bodies = { sun, mercury, venus, earth, mars, jupiter, saturn, uranus, neptune };

    const earthMoonSystem = new PlanetMoonSystem(earth, [luna]);
    solarSystemGroup.add(earthMoonSystem);
    earthMoonSystem.update(0, 1); // set initial position
    earth.enableTrail({maxPoints: 450, color: 0x00bbff});

    const noMoonsMercury = new PlanetMoonSystem(mercury);
    solarSystemGroup.add(noMoonsMercury);
    noMoonsMercury.update(0, 1);
    mercury.enableTrail({maxPoints: 500, color: 0xaaff00});

    const noMoonsVenus = new PlanetMoonSystem(venus);
    solarSystemGroup.add(noMoonsVenus);
    noMoonsVenus.update(0, 1);
    venus.enableTrail({maxPoints: 600, color: 0xff0000});

    const marsWithMoons = new PlanetMoonSystem(mars, [phobos, deimos]);
    solarSystemGroup.add(marsWithMoons);
    marsWithMoons.update(0, 1);
    mars.enableTrail({maxPoints: 1600, color: 0xffaa00});

    const jupiterWithMoons = new PlanetMoonSystem(jupiter, [callisto, europa, ganymede, io]);
    solarSystemGroup.add(jupiterWithMoons);
    jupiterWithMoons.update(0, 1);
    jupiter.enableTrail({maxPoints: 1600, color: 0xdd00dd});

    const saturnWithMoons = new PlanetMoonSystem(saturn, [dione, enceladus, tethys, titan]);
    solarSystemGroup.add(saturnWithMoons);
    saturnWithMoons.update(0, 1);
    saturn.enableTrail({maxPoints: 1600, color: 0xffff00});

    const uranusWithMoons = new PlanetMoonSystem(uranus, []);
    solarSystemGroup.add(uranusWithMoons);
    uranusWithMoons.update(0, 1);
    uranus.enableTrail({maxPoints: 1600, color: 0xaaaaaa});

    const neptuneWithMoons = new PlanetMoonSystem(neptune, []);
    solarSystemGroup.add(neptuneWithMoons);
    neptuneWithMoons.update(0, 1);
    neptune.enableTrail({maxPoints: 1600, color: 0x0000ff});

    const solarSystem = [
        earthMoonSystem,
        noMoonsMercury,
        noMoonsVenus,
        marsWithMoons,
        jupiterWithMoons,
        saturnWithMoons,
        uranusWithMoons,
        neptuneWithMoons
    ];

    const controlsGui = new ControlsGui();
    document.querySelectorAll("#planetControls button")
        .forEach(button => {
            button.addEventListener("click", () => {
                const body = bodies[button.dataset.body];
                if (body) controlsGui.focusOnObject(body);
            });
        });

    document.getElementById("resetCamera").addEventListener("click", () => {
        planetCamera.position.copy(cameraStart.position);
        controls.target.copy(cameraStart.target);
        controls.update();
    });


    let lastTime = 0;
    const frameRate = 20;
    let t = 0;
    function animate(time) {
        if (time - lastTime < 1000 / frameRate) return;
        lastTime = time;

        solarSystem.forEach(body => body.update(t, dt));
        t += dt;

        skyDome.update(time * .001, planetCamera);
        planetRenderer.render(planetaryScene, planetCamera);
        controlsGui.render();
    }

</script>