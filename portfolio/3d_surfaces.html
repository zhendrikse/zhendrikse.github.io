<style>
    #canvas-wrapper {
        position: relative;
        width: 600px;
        height: 700px;
    }

    #geometriesCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    #gui-container {
        position: absolute;
        bottom: 5px;      /* distance from the bottom of the canvas */
        left: 10px;
        z-index: 20;
    }

    #surface-title {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        font-size: 24px;
        font-family: sans-serif;
        color: yellow;
        z-index: 10;  /* above canvas */
        pointer-events: none;
        font-weight: bold;
        text-shadow: 0 0 8px black;
    }

    #surface-equation {
        position: absolute;
        top: 50px;
        font-size: 14px;
        color: yellow;
        margin-left: 5px;
        margin-right: 10px;
        text-align: left;
        width: 600px;
        z-index: 10;  /* above canvas */
    }

    #surface-equation .mjx-chtml {
        display: block;                 /* make MathJax fill the div */
        max-width: 100%;
    }
</style>

<div id="canvas-wrapper">
    <div id="gui-container"></div>
    <div id="surface-title"></div>
    <div id="surface-equation"></div>
    <canvas id="geometriesCanvas" width="600" height="700"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.js" type="text/javascript"></script>
<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import {ParametricGeometry} from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/geometries/ParametricGeometry";
    import {OrbitControls} from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm";

    const canvas = document.getElementById("geometriesCanvas"),
        width = canvas.width,
        height = canvas.height;

    const Category = Object.freeze({
        BASIC: "Basic",
        CONIC: "Conics",
        MISC: "Miscellaneous",
        SPIRAL: "Spiral",
        TOROID: "Toroid"
    });

    const ColorMode = Object.freeze({
        BASE: "Base",
        GAUSSIAN: "Gaussian curvature",
        HEIGHT: "Height",
        MEAN: "Mean curvature",
        K1: "Principal curvature kâ‚",
        K2: "Principal curvature kâ‚‚"
    });

    const ContourType = {
        CURVATURE: "Curvature",
        ISO_PARAMETRIC: "Isoparametric",
        NONE: "None"
    }

    const surfaces = [{
        meta: {name: "Arc", category: Category.MISC},
        parametrization: {
            xFn: "cos(u)",
            yFn: "3 * sin(v)",
            zFn: "sin(u) + cos(v)"
        },
        intervals: [["0", "pi"], ["pi", "0"]]
    }, {
        meta: {name: "Bohemian dome", category: Category.MISC},
        parametrization: {
            xFn: "7 * cos(u)",
            yFn: "7 * sin(u) + 3 * cos(v)",
            zFn: "6 * sin(v)"
        },
        intervals: [["0", "2 * pi"], ["4 * pi", "0"]]
    }, {
        meta: {name: "Bow curve", category: Category.TOROID},
        parametrization: {
            xFn: "(1 * sin(u) + 2) * sin(v)",
            yFn: "(1 * sin(u) + 2) * cos(v)",
            zFn: "1 * cos(u) + 2 * cos(1/2 * v)"
        },
        intervals: [["0", "2 * pi"], ["4 * pi", "0"]]
    }, {
        meta: {name: "Bow tie", category: Category.MISC},
        parametrization: {
            xFn: "sin(u)/ (sqrt(2) + sin(v))",
            yFn: "sin(u)/ (sqrt(2) + cos(v))",
            zFn: "cos(u)/ (sqrt(2) + 1)"
        },
        intervals: [["-pi", "pi"], ["pi", "-pi"]]
    }, {
        meta: {name: "Conchoidal", category: Category.SPIRAL},
        parametrization: {
            xFn: "1.2 ^u * (1 + cos(v)) * cos(u)",
            yFn: "1.2 ^u * sin(v) - 1.5 * 1.2 ^u",
            zFn: "1.2 ^u * (1 + cos(v)) * sin(u)"
        },
        intervals: [["0", "6 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Cone", category: Category.CONIC},
        parametrization: {
            xFn: "v * cos(u)",
            yFn: "v",
            zFn: "v * sin(u)"
        },
        intervals: [["0", "2 * pi"], ["1/2", "-1/2 + 1e-4"]]
    }, {
        meta: {name: "Cylinder", category: Category.BASIC},
        parametrization: {
            xFn: "1 * cos(u)",
            yFn: "v",
            zFn: "1 * sin(u)"
        },
        intervals: [["0", "2 * pi"], ["3", "0"]]
    }, {
        meta: {name: "Crescent", category: Category.SPIRAL},
        parametrization: {
            xFn: "(2 + sin(2 * pi * u) * sin(2 * pi * v)) * sin(3 * pi * v)",
            yFn: "(2 + sin(2 * pi * u) * sin(2 * pi * v)) * cos(3 * pi * v)",
            zFn: "cos(2 * pi * u) sin(2 * pi * v) + 4 * v - 2"
        },
        intervals: [["0", "1"], ["1", "0"]]
    }, {
        meta: {name: "Dini\'s spiral", category: Category.SPIRAL},
        parametrization: {
            xFn: "1.5 * cos(u) * sin(v)",
            yFn: "(cos(v) + log(tan(v / 2))) + 1 / 10 * u",
            zFn: "1.5 * sin(u) * sin(v)"
        },
        intervals: [["0", "4 * pi"], ["2 - 0.1", "0 + 0.1"]]
    }, {
        meta: {name: "Ellipsoid", category: Category.CONIC},
        parametrization: {
            xFn: "2 * sin(u) * sin(v)",
            yFn: "1 * cos(u) * sin(v)",
            zFn: "3 * cos(v)"
        },
        intervals: [["-pi/2", "pi/2"], ["2 * pi - 1e-4", "1e-4"]]
    }, {
        meta: {name: "Elliptic torus", category: Category.TOROID},
        parametrization: {
            xFn: "(1 * cos(v) + 3) * cos(u)",
            yFn: "1 * (cos(v) + sin(v))",
            zFn: "(1 * cos(v) + 3) * sin(u)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Goblet", category: Category.MISC},
        parametrization: {
            xFn: "cos(u) * cos(2 * v)",
            yFn: "-sin(v)",
            zFn: "sin(u) * cos(2 * v)"
        },
        intervals: [["0", "2 * pi"], ["pi", "0"]]
    }, {
        meta: {name: "Horn", category: Category.SPIRAL},
        parametrization: {
            xFn: "(2 + u * cos(v)) * sin (2 * pi * u)",
            yFn: "(2 + u * cos(v)) * cos (2 * pi * u) + u",
            zFn: "u * sin(v)"
        },
        intervals: [["0", "1"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Hyperbolic paraboloid", category: Category.CONIC},
        parametrization: {
            xFn: "u",
            yFn: "u * v",
            zFn: "v"
        },
        intervals: [["-1", "1"], ["1", "-1"]]
    }, {
        meta: {name: "Hyperboloid / Catenoid", category: Category.CONIC},
        parametrization: {
            xFn: "cosh(4 * v / 5) * cos(u)",
            yFn: "5 * v /4",
            zFn: "cosh(4 * v / 5) * sin(u)"
        },
        intervals: [["0", "2 * pi"], ["2", "-2"]]
    }, {
        meta: {name: "MÃ¶bius strip", category: Category.MISC},
        parametrization: {
            xFn: "(2 + u * cos(v / 2)) * cos(v)",
            yFn: "(2 + u * cos(v / 2)) * sin(v)",
            zFn: "u * sin(v / 2)",
        },
        intervals: [["-1", "1"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Limpet torus", category: Category.TOROID},
        parametrization: {
            xFn: "cos(u) / (sqrt(2) + sin(v))",
            yFn: "1 / (sqrt(2) + cos(v))",
            zFn: "sin(u) / (sqrt(2) + sin(v))",
        },
        intervals: [["0", "2 * pi"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Paraboloid", category: Category.CONIC},
        parametrization: {
            xFn: "2 * sqrt(u / 1) * cos(v)",
            yFn: "3 * u",
            zFn: "2 * sqrt(u / 1) * sin(v)"
        },
        intervals: [["1e-5", "1 - 1e-5"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Pillow", category: Category.MISC},
        parametrization: {
            xFn: "cos(u)",
            yFn: "0.7 * sin(u) * sin(v)",
            zFn: "cos(v)"
        },
        intervals: [["0", "pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Plane", category: Category.BASIC},
        parametrization: {
            xFn: "1.5 * u - 1 * v + 1",
            yFn: "-u - v - 0.5",
            zFn: "u + v + 1"
        },
        intervals: [["-3/2", "3/2"], ["3/2", "-3/2"]]
    }, {
        meta: {name: "Saddle / hyperbolic paraboloid", category: Category.BASIC},
        parametrization: {
            xFn: "u * sin(v)",
            yFn: "1.25 * u * cos(v) * u * sin(v)",
            zFn: "u * cos(v)"
        },
        intervals: [["1e-3", "1 - 1e-3"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Sea shell", category: Category.SPIRAL},
        parametrization: {
            xFn: "2 * (1 - v / (2 * pi)) * cos(3 * v) * (1 + cos(u)) + 0.25 * cos(3 * v)",
            yFn: "(7 * v / (2 * pi)) + 2 * (1 - v / (2 * pi)) * sin(u)",
            zFn: "2 * (1 - v / (2 * pi)) * sin(3 * v) * (1 + cos(u)) + 0.25 * sin(3 * v)"
        },
        intervals: [["0", "2 * pi"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Sine", category: Category.MISC},
        parametrization: {
            xFn: "sin(u)",
            yFn: "sin(v)",
            zFn: "sin(u + v)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Sphere", category: Category.BASIC},
        parametrization: {
            xFn: "1 * cos(u) * sin(v)",
            yFn: "1 * sin(u) * sin(v)",
            zFn: "1 * cos(v)"
        },
        intervals: [["0", "2 * pi"], ["pi - 1e-4", "1e-4"]]
    }, {
        meta: {name: "Spring", category: Category.SPIRAL},
        parametrization: {
            xFn: "(1 - 1/5 * cos(v)) * cos(u)",
            yFn: "1/4 * (sin(v) + 2 * u / pi)",
            zFn: "(1 - 1/5 * cos(v)) * sin(u)"
        },
        intervals: [["0", "8 * pi"], ["0", "2 * pi"]]
    }, {
        meta: {name: "Torus", category: Category.TOROID},
        parametrization: {
            xFn: "cos(u) * (3 + 1.5 * cos(v))",
            yFn: "1.5 * sin(v)",
            zFn: "sin(u) * (3 + 1.5 * cos(v))"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    }, {
        meta: {name: "Trefoil knot", category: Category.TOROID},
        parametrization: {
            xFn: "(4 * (1 + 1/4 * sin(3 * v)) + cos(u)) * cos(2 * v)",
            yFn: "(4 * (1 + 1/4 * sin(3 * v)) + cos(u)) * sin(2 * v)",
            zFn: "sin(u) + 2 * cos(3 * v)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    },{
        meta: {name: "Twisted torus", category: Category.TOROID},
        parametrization: {
            xFn: "(2 + sin(v) + cos(u)) * cos(2 * v)",
            yFn: "(2 + sin(v) + cos(u)) * sin(2 * v)",
            zFn: "sin(u) + 3 * cos(v)"
        },
        intervals: [["0", "2 * pi"], ["2 * pi", "0"]]
    },{
        meta: {name: "Whitney umbrella", category: Category.MISC},
        parametrization: {
            xFn: "u * v",
            yFn: "2 * v * v",
            zFn: "u"
        },
        intervals: [["-2", "2"], ["-2", "2"]]
    }];

    class Utils {
        static scaleBox3(box, factor) {
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();

            box.getCenter(center);
            box.getSize(size);

            size.multiplyScalar(factor).multiplyScalar(0.5);

            box.min.copy(center).sub(size);
            box.max.copy(center).add(size);

            return box;
        }

        static fitGroupToBox(
            group,     // ðŸ‘ˆ This object moves
            sourceBox,
            targetBox,
            { alignY = "min", padding = 1.0 } = {}
        ) {
            const sourceSize = new THREE.Vector3();
            const targetSize = new THREE.Vector3();
            const sourceCenter = new THREE.Vector3();
            const targetCenter = new THREE.Vector3();

            sourceBox.getSize(sourceSize);
            targetBox.getSize(targetSize);
            sourceBox.getCenter(sourceCenter);
            targetBox.getCenter(targetCenter);

            const scale = Math.min(
                targetSize.x / sourceSize.x,
                targetSize.y / sourceSize.y,
                targetSize.z / sourceSize.z
            ) / padding;

            group.scale.setScalar(scale);

            sourceCenter.multiplyScalar(scale);
            group.position.copy(targetCenter).sub(sourceCenter);

            if (alignY === "min") {
                group.updateMatrixWorld(true);
                const scaledBox = new THREE.Box3().setFromObject(group);
                const deltaY = targetBox.min.y - scaledBox.min.y;
                group.position.y += deltaY;
            }
        }



        static functionFrom(xyFunctionString) {
            try {
                return (u, v) => math.compile(xyFunctionString).evaluate({ u, v });
            } catch (err) {
                alert("Math.js parse error: " + err.message);
                return null;
            }
        }
    }

    class Scenery {
        constructor(scene, worldGroup) {
            this.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 100);
            this.renderer = this.#createRenderer();
            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.scene = scene;

            this.controls.enableDamping = true;
            this.camera.position.set(6, 3, 6);
            this.scene.background = new THREE.Color(0x131313);

            this.scene.add(worldGroup);
            this.scene.add(this.#createDirectionalLight());
            this.scene.add(this.#createHemisphereLight());
        }

        #createHemisphereLight =
            (skyColour=0x87ceeb, groundColour=0x444444) => new THREE.HemisphereLight(skyColour, groundColour, 0.8);

        #createDirectionalLight() {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 10, 7.5); // kind of "sunlight"
            directionalLight.castShadow = true; // Enable shadows
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            return directionalLight;
        }

        #createRenderer() {
            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
            renderer.setSize(width, height);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            return renderer;
        }

        setSize(width, height) {
            this.renderer.setSize(width, height);
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
        }

        updateSurfaceData(surfaceData) {
            const nameDiv = document.getElementById("surface-title");
            nameDiv.textContent = surfaceData.meta.category + ": " + surfaceData.meta.name;

            const equationDiv = document.getElementById("surface-equation");
            equationDiv.innerHTML = "$$\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix}" +
                surfaceData.parametrization.xFn + " \\\\" +
                surfaceData.parametrization.yFn + " \\\\" +
                surfaceData.parametrization.zFn + "\\end{pmatrix}\\text{, } \\begin{cases} u \\in [" +
                surfaceData.intervals[0][0] + ", " +
                surfaceData.intervals[0][1] + "] \\\\ v \\in [" +
                surfaceData.intervals[1][0] + ", " +
                surfaceData.intervals[1][1] + "] \\end{cases}$$";
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, equationDiv]);
            //MathJax.typesetPromise([equationDiv]);
        }

        fitToBoundingBox(boundingBox, {
            padding = 1.5,
            translationY = 0,
            minDistance = 2
        } = {}) {
            const size = new THREE.Vector3();
            let center = new THREE.Vector3();

            boundingBox.getSize(size);
            boundingBox.getCenter(center);

            const maxDim = Math.max(size.x, size.y, size.z);
            const verticalFieldOfView = THREE.MathUtils.degToRad(this.camera.fov);

            // distance so that bounding box is always in view
            let distance = maxDim / Math.tan(verticalFieldOfView / 2);
            distance = Math.max(distance * padding, minDistance);
            const direction = new THREE.Vector3(1, 1, 1).normalize(); // Matlab-like camera setting

            this.camera.position
                .copy(new THREE.Vector3(center.x, center.y + translationY, center.z))
                .addScaledVector(direction, distance);

            this.camera.near = distance / 100;
            this.camera.far  = distance * 10;
            this.camera.updateProjectionMatrix();

            this.controls.target.copy(center);
            this.controls.update();
        }

        render() {
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    }

    class ViewParameters {
        constructor({
                        baseColor = "#ff4",
                        category = Category.BASIC,
                        colorMode = ColorMode.HEIGHT,
                        contourType = ContourType.ISO_PARAMETRIC,
                        normals = false,
                        opacity = 0.9,
                        resolution = 50,
                        showAxes = true,
                        wireframe = false
                    } ={}) {
            this.baseColor = baseColor;
            this.category = category;
            this.colorMode = colorMode;
            this.contourType = contourType;
            this.wireframe = wireframe;
            this.showAxes = showAxes;
            this.normals = normals;
            this.resolution = resolution;
            this.opacity = opacity;
        }
    }

    class ControlsGui {
        constructor(scenery, surface, axes, ring, viewParameters=new ViewParameters()) {
            this.viewParameters = viewParameters;
            this.surface = surface;
            const controls = new GUI({width: 275, autoPlace: false});
            document.getElementById("gui-container").appendChild(controls.domElement);

            controls.add(this.viewParameters, 'category', Object.values(Category))
                .name("Category")
                .onChange(value => ring.changeActiveCategoryTo(value));

            this.#createAppearanceFolder(controls, axes);

            const contourFolder = controls.addFolder("Contours");
            contourFolder.add(this.viewParameters, "contourType", Object.values(ContourType))
                .name("Contour type")
                .onChange(value => this.surface.changeContourTypeTo(value));
            contourFolder.close();
            controls.close();

            // appearanceFolder.add(params, "resolution", 10, 200, 1)
            //     .name("Resolution")
            //     .onChange(resolution => surface.resampleWith(resolution));
            //
            // appearanceFolder.add({reset: () => scenery.fitToBoundingBox(surfaceInAxes.boundingBox())}, "reset")
            //     .name("Reset Camera");
            //
            // const contourParams = {uCount: 20, vCount: 20, visible: true, color: params.baseColor, opacity: params.opacity};
            // contourFolder.add(contourParams, "uCount", 1, 40, 1)
            //     .name("U contours")
            //     .onChange(() => {
            //         surface.clearContours();
            //         surface.addContoursWith(contourParams);});
            // contourFolder.add(contourParams, "vCount", 1, 40, 1)
            //     .name("V contours")
            //     .onChange(() => {
            //         surface.clearContours();
            //         surface.addContoursWith(contourParams);});
            // contourFolder.add(contourParams, "visible")
            //     .name("Show contours")
            //     .onChange(value => value ?
            //         surface.addContoursWith({color: params.baseColor, opacity: params.opacity}) :
            //         surface.clearContours(value));
            //
            // const animationFolder = controls.addFolder("Animation Controls");
            // animationFolder.add(params, 'frequency', 0, 2).step(0.01).name("Frequency");
            // animationFolder.add(params, 'animate').name("Animate");
            //
            // controls.close();
            // animationFolder.close();
            // contourFolder.close();
            // appearanceFolder.close();
        }

        #createAppearanceFolder(controls, axes) {
            const appearanceFolder = controls.addFolder("Appearance");
            appearanceFolder.add(this.viewParameters, "colorMode", Object.values(ColorMode))
                .name("Color Mode")
                .onChange(() => this.surface.changeColorModeTo(this.viewParameters.colorMode));
            appearanceFolder.add(this.viewParameters, 'baseColor')
                .name("Base color")
                .onChange(() => {if (this.#isValidColor()) this.surface.changeBaseColorTo(this.viewParameters.baseColor);});
            appearanceFolder.add(this.viewParameters, "opacity", 0, 1, .01)
                .name("Opacity")
                .onChange(value => this.surface.changeOpacityTo(value));
            appearanceFolder.add(this.viewParameters, 'wireframe')
                .name("Wireframe")
                .onChange(value => this.surface.toggleWireframe(value));
            appearanceFolder.add(this.viewParameters, 'showAxes')
                .name("Axes").onChange(value => axes.show(value));
            appearanceFolder.add(this.viewParameters, 'normals')
                .name('Show Normals')
                .onChange(value => this.#showNormals(this.surface, value));
            appearanceFolder.close();
        }

        #isValidColor() {
            const style = new Option().style;
            style.color = this.viewParameters.baseColor;
            return style.color !== '';
        }

        #showNormals(surface, show) {
            if (show) {
                surface.addNormalsWith({});
                surface.changeOpacityTo(0.3);
            } else {
                surface.clearNormals();
                surface.changeOpacityTo(this.viewParameters.opacity);
            }
        }

        updateSurfaceWith= (newSurface) => this.surface = newSurface;
    }

    class MatlabAxes {
        constructor(parentGroup, axesSize=3, gridDivisions=10) {
            this.group = new THREE.Group();

            this.#createGrids(axesSize, gridDivisions);
            this.#createPlanes(axesSize);
            this.group.add(this.#createAxes(axesSize));

            parentGroup.add(this.group);
        }

        #createGrids(axesSize, gridDivisions) {
            const gridXZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridXZ.rotation.x = Math.PI / 2;
            gridXZ.position.set(0, .5 * axesSize, -0.5 * axesSize);
            this.group.add(gridXZ);

            const gridYZ = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            gridYZ.rotation.z = Math.PI / 2;
            gridYZ.position.set(-0.5 * axesSize, .5 * axesSize, 0);
            this.group.add(gridYZ);

            const gridXY = new THREE.GridHelper(axesSize, gridDivisions, 0x444444, 0x444444);
            this.group.add(gridXY);
        }

        #createPlanes(axesSize) {
            const planeXZ = this.#createPlane(axesSize, 0, 0, 0);
            planeXZ.rotation.x = -Math.PI / 2;

            const planeYZ = this.#createPlane(axesSize, -0.5, 0.5, 0);
            planeYZ.rotation.y = -Math.PI / 2;

            this.#createPlane(axesSize, 0, 0.5, -0.5);
        }

        #createAxes(axesSize) {
            const eps = .025
            const axesHelper = new THREE.AxesHelper(axesSize);
            axesHelper.position.set(-.5 * axesSize + eps, eps, -.5 * axesSize +eps);
            return axesHelper;
        }

        #createPlane(size, x, y, z, opacity=0.10, color=0x888888) {
            const material = new THREE.MeshPhongMaterial({
                color: color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: opacity
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(size, size), material);
            mesh.position.set(x * size, y * size, z * size);
            this.group.add(mesh);
            return mesh;
        }

        boundingBox = () => {
            this.group.updateMatrixWorld(true);
            return new THREE.Box3().setFromObject(this.group).clone();
        }
        show = (value) => this.group.visible = value;
    }

    class Interval {
        constructor(from=-Infinity, to=Infinity) {
            this.from = from;
            this.to = to;
        }

        shrinkTo(value) {
            if (this.from < value) this.from = value;
            if (this.to > value) this.to = value;
        }

        scaleValue = (value) => this.to !== this.from ? (value - this.from) / this.range() : 0;
        range = () => (this.from === Infinity || this.to === Infinity) ? Infinity : this.to - this.from;
        scaleParameter = (a) => this.range() * (a + this.from / this.range());
    }

    class SurfaceDefinition {
        sample(u, v, target) {
            throw new Error("sample() not implemented");
        }

        heightComponent(targetVec) { return targetVec.y; }
        usesGroundLifting() { return true; }
    }

    class LiteralStringBasedSurfaceDefinition extends SurfaceDefinition {
        constructor(surfaceFunctions, xInterval, yInterval) {
            super();

            this.xFnCompiled = Utils.functionFrom(surfaceFunctions.xFn);
            this.yFnCompiled = Utils.functionFrom(surfaceFunctions.yFn);
            this.zFnCompiled = Utils.functionFrom(surfaceFunctions.zFn);

            this.xInterval = new Interval(this.#evaluateConstant(xInterval[0]), this.#evaluateConstant(xInterval[1]));
            this.yInterval = new Interval(this.#evaluateConstant(yInterval[0]), this.#evaluateConstant(yInterval[1]));
        }

        #evaluateConstant = (exprString) => Utils.functionFrom(exprString)(0, 0);

        sample(u, v, target) {
            const theta = this.xInterval.scaleParameter(u);
            const phi = this.yInterval.scaleParameter(v);

            target.set(
                this.xFnCompiled(theta, phi),
                this.yFnCompiled(theta, phi),
                this.zFnCompiled(theta, phi)
            );
        }
    }

    class Surface {
        constructor(surfaceData) {
            this.surfaceData = surfaceData;
            const definition = new LiteralStringBasedSurfaceDefinition(
                surfaceData.parametrization,
                surfaceData.intervals[0],
                surfaceData.intervals[1]);

            this.surfaceFunction = (u, v, target) => definition.sample(u, v, target);
        }

        createGeometryWith = (resolution) =>
            new ParametricGeometry((u, v, target) => this.surfaceFunction(u, v, target), resolution, resolution);

        data = () => this.surfaceData;
        parametrization = () => this.surfaceFunction;
    }

    class SurfaceView {
        constructor(parentGroup, surface) {
            this.parentGroup = parentGroup;
            this.surface = surface;
            this.group = new THREE.Group();
            this.parentGroup?.add(this.group);
            this._children = new Set();
        }

        #disposeSubViews = () => {
            for (const child of this._children) child.dispose?.();
            this._children.clear();
        }

        #disposeChild(child) {
            if (child.geometry) child.geometry.dispose();

            if (!child.material) return;
            if (Array.isArray(child.material))
                child.material.forEach(m => m.dispose());
            else
                child.material.dispose();
        }

        registerChild(view) {
            this._children.add(view);
            return view;
        }

        dispose() {
            this.#disposeSubViews();
            this._disposeObject(this.group);
            if (this.parentGroup) this.parentGroup.remove(this.group);
            this.group = null;
            this.parentGroup = null;
        }

        /** Deep Three.js cleanup */
        _disposeObject(object) {
            object.traverse(child => { if (child.isMesh) this.#disposeChild(child); });
            object.clear();
        }

        boundingBox() { return new THREE.Box3().setFromObject(this.group).clone(); }
        data() { return this.surface.data(); }
        hide() { this.group.visible = false; }
        moveTo(positionAsVector) { this.group.position.copy(positionAsVector); }
        material = (showWireframe, opacity) =>
            new THREE.MeshPhongMaterial({vertexColors: true, side: THREE.DoubleSide, wireframe: showWireframe, opacity: opacity, emissive: 0x222222});
        parametrization() { return this.surface.parametrization(); }
        position() { return this.group.position.clone(); }
        rotateBy = (delta) => this.group.rotation.y += delta;
        show() { this.group.visible = true; }
    }

    class SurfaceSelectorView extends SurfaceView {
        constructor(parentGroup, surface, {resolution=20, baseColor="#4f6"}) {
            super(parentGroup, surface);
            this.baseColor = baseColor;
            this.geometry = surface.createGeometryWith(resolution);
            this.material = this.material(true, 1);
            this.colorMapper = new HeightColorMapper({ baseColor: baseColor });
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.group.add(this.mesh);
            this.colorMapper.apply(this.geometry);
        }

        onSelect = () => {
            this.material.wireframe = false;
            this.colorMapper = new HeightColorMapper({});
            this.colorMapper.apply(this.geometry); }
        onDeselect = () => {
            this.material.wireframe = true;
            this.colorMapper = new HeightColorMapper({ baseColor: this.baseColor });
            this.colorMapper.apply(this.geometry); }
        selectableObject = () => this.mesh;
    }

    class DisplayedSurfaceView extends SurfaceView {
        constructor(parentGroup, surface, visualizationParameters) {
            super(parentGroup, surface);
            this.baseColor = visualizationParameters.baseColor;
            this.opacity = visualizationParameters.opacity;
            this.geometry = surface.createGeometryWith(visualizationParameters.resolution);
            this.material = this.material(visualizationParameters.wireframe, this.opacity);
            this.changeOpacityTo(this.opacity);
            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.group.add(this.mesh);
            this.colorMapper = null;
            this.colorMode = visualizationParameters.colorMode;
            this.changeColorModeTo(visualizationParameters.colorMode);
            this.contours = null;
            this.changeContourTypeTo(visualizationParameters.contourType);
            this.normals = this.registerChild(new NormalsView(this.group, surface, this.geometry));
        }

        addContoursWith = (contourParameters) => this.contours.buildWith(contourParameters);
        addNormalsWith = (normalParameters) => this.normals.buildWith(normalParameters);

        changeColorModeTo(mode) {
            switch (mode) {
                case ColorMode.HEIGHT:
                    this.colorMapper = new HeightColorMapper({ useBaseColor: false });
                    break;
                case ColorMode.MEAN:
                    this.colorMapper = new CurvatureColorMapper(this.surface);
                    break;
                case ColorMode.K1:
                case ColorMode.K2:
                    this.colorMapper = new PrincipalCurvatureColorMapper(this.surface, { which: mode, scale: 3.0 });
                    break;
                case ColorMode.GAUSSIAN:
                    this.colorMapper =
                        new GaussianCurvatureColorMapper(this.surface, {
                            scale: 3.0 // Scale determines how "fast" the color saturates. For sphere/torus -> [1 .. 3]
                        });
                    break;
                case ColorMode.BASE:
                default:
                    this.colorMapper = new HeightColorMapper({ baseColor: this.baseColor, useBaseColor: true});
            }
            this.colorMapper.apply(this.geometry);
        }

        changeContourTypeTo(mode) {
            if (this.contours) this.contours.clear();
            switch (mode) {
                case ContourType.NONE:
                    return;
                case ContourType.CURVATURE:
                    this.contours = this.registerChild(new CurvatureContoursView(this.group, this.surface));
                    break;
                case ContourType.ISO_PARAMETRIC:
                    this.contours = this.registerChild(new IsoparametricContoursView(this.group, this.surface));
                    break;
            }
            this.contours.buildWith({
                color: this.baseColor,
                opacity: this.opacity
            });
        }

        changeBaseColorTo = (value) => {
            this.baseColor = value;
            this.changeColorModeTo(this.colorMode);
            if (this.contours && this.contours.visible()) {
                this.contours.dispose();
                this.addContoursWith({color: this.baseColor});
            }
        };
        changeOpacityTo = (value) => { this.material.opacity = value; this.material.transparent = value < 1; }
        clearNormals = () => this.normals.clear();

        resampleWith(resolution) {
            this.geometry.dispose();
            this.geometry = this.surface.createGeometryWith(resolution);
            this.mesh.geometry = this.geometry;
            this.colorMapper.apply(this.geometry);
        }

        resetTransform() {
            this.group.position.set(0, 0, 0);
            this.group.rotation.set(0, 0, 0);
            this.group.scale.set(1, 1, 1);
        }

        toggleWireframe = (value) => this.material.wireframe = value;
    }

    class ColorMapper {
        apply(geometry) {
            throw new Error("apply() not implemented");
        }
    }

    class HeightColorMapper extends ColorMapper {
        constructor({ baseColor = "#ff4", useBaseColor = true } = {}) {
            super();
            this.baseColor = baseColor;
            this.useBaseColor = useBaseColor;
        }

        #computeYRange(posAttr) {
            const yRange = new Interval();
            for (let i = 0; i < posAttr.count; i++)
                yRange.shrinkTo(posAttr.getY(i));

            return yRange;
        }

        apply(geometry) {
            const posAttr = geometry.attributes.position;
            const count = posAttr.count;

            let colorAttr = geometry.attributes.color;
            if (!colorAttr) {
                const colors = new Float32Array(count * 3);
                colorAttr = new THREE.BufferAttribute(colors, 3);
                geometry.setAttribute("color", colorAttr);
            }

            const yRange = this.#computeYRange(posAttr);
            const color = new THREE.Color();
            const hsl = {};

            for (let i = 0; i < count; i++) {
                const y = posAttr.getY(i);
                const t = yRange.scaleValue(y);

                if (this.useBaseColor) {
                    color.setStyle(this.baseColor);
                    color.getHSL(hsl);
                    hsl.l = 0.1 + 0.3 * (1 - t);
                } else {
                    hsl.h = t * 0.5 - 0.025;
                    hsl.s = 0.9;
                    hsl.l = 0.4 + 0.2 * (1 - t);
                }

                color.setHSL(hsl.h, hsl.s, hsl.l);
                colorAttr.array[3*i]     = color.r;
                colorAttr.array[3*i + 1] = color.g;
                colorAttr.array[3*i + 2] = color.b;
            }

            colorAttr.needsUpdate = true;
        }
    }

    class CurvatureColorMapper extends ColorMapper {
        constructor(surface) {
            super();
            this.curvature = new DifferentialGeometry(surface.parametrization());
        }

        #setColorFromCurvature(u, v, color) {
            const H = this.curvature.meanCurvature(u, v);
            const t = THREE.MathUtils.clamp(Math.abs(H) * 2.0, 0, 1);
            color.setHSL(0.6 - 0.6 * t, 0.9, 0.5);
        }

        apply(geometry) {
            const pos = geometry.attributes.position;
            const uv = geometry.attributes.uv;
            const color = new THREE.Color();
            let colorAttr = geometry.attributes.color;
            if (!colorAttr) {
                const colors = new Float32Array(pos.count * 3);
                colorAttr = new THREE.BufferAttribute(colors, 3);
                geometry.setAttribute("color", colorAttr);
            }

            for (let i = 0; i < pos.count; i++) {
                const u = uv.getX(i), v = uv.getY(i);
                this.#setColorFromCurvature(u, v, color);
                colorAttr.array[3 * i] = color.r;
                colorAttr.array[3 * i + 1] = color.g;
                colorAttr.array[3 * i + 2] = color.b;
            }
            colorAttr.needsUpdate = true;
        }
    }

    class GaussianCurvatureColorMapper extends ColorMapper {
        constructor(surface, {
            scale = 1.0,
            clamp = 1.0
        } = {}) {
            super();
            this.curvature = new DifferentialGeometry(surface.parametrization());
            this.scale = scale;
            this.clamp = clamp;
        }

        #colorFromK(K, color) {
            // Symmetric scale around 0
            const t = Math.tanh(K * this.scale);
            if (t > 0)
                color.setHSL(0.0, 0.85, 0.5 + 0.2 * t); // positive (elliptic): red
            else
                color.setHSL(0.6, 0.85, 0.5 - 0.2 * t); // negative (hyperbolic): blue
        }

        apply(geometry) {
            const pos = geometry.attributes.position;
            const uv  = geometry.attributes.uv;

            let colorAttr = geometry.attributes.color;
            if (!colorAttr) {
                const colors = new Float32Array(pos.count * 3);
                colorAttr = new THREE.BufferAttribute(colors, 3);
                geometry.setAttribute("color", colorAttr);
            }

            const color = new THREE.Color();

            for (let i = 0; i < pos.count; i++) {
                const u = uv.getX(i);
                const v = uv.getY(i);

                const K = this.curvature.gaussianCurvature(u, v);
                this.#colorFromK(K, color);

                colorAttr.array[3 * i]     = color.r;
                colorAttr.array[3 * i + 1] = color.g;
                colorAttr.array[3 * i + 2] = color.b;
            }

            colorAttr.needsUpdate = true;
        }
    }

    class PrincipalCurvatureColorMapper extends ColorMapper {
        constructor(surface, {
            which = ColorMode.K1,
            scale = 1.0
        } = {}) {
            super();
            this.geom = new DifferentialGeometry(surface.parametrization());
            this.which = which;
            this.scale = scale;
        }

        apply(geometry) {
            const pos = geometry.attributes.position;
            const uv  = geometry.attributes.uv;

            let colorAttr = geometry.attributes.color;
            if (!colorAttr) {
                colorAttr = new THREE.BufferAttribute(
                    new Float32Array(pos.count * 3), 3
                );
                geometry.setAttribute("color", colorAttr);
            }

            const color = new THREE.Color();

            for (let i = 0; i < pos.count; i++) {
                const u = uv.getX(i);
                const v = uv.getY(i);

                const { k1, k2 } = this.geom.principalCurvatures(u, v);
                const k = this.which === ColorMode.K1 ? k1 : k2;

                // diverging color map
                const t = Math.tanh(k * this.scale);

                if (t > 0)
                    color.setHSL(0.0, 0.85, 0.5 + 0.25 * t); // red
                else
                    color.setHSL(0.6, 0.85, 0.5 - 0.25 * t); // blue

                colorAttr.array[3 * i]     = color.r;
                colorAttr.array[3 * i + 1] = color.g;
                colorAttr.array[3 * i + 2] = color.b;
            }

            colorAttr.needsUpdate = true;
        }
    }

    class IsoparametricContoursView extends SurfaceView {
        constructor(parentGroup, surface) {
            super(parentGroup, surface)
            this.material = null;
            this.lines = [];
        }

        #addLine(points, material) {
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            this.group.add(line);
            this.lines.push(line);
        }

        buildWith({
                      uCount = 20,
                      vCount = 20,
                      segments = 100,
                      color = 0xffffff,
                      opacity = 0.8
                  } = {}) {
            this.clear();

            const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity, depthWrite: false });
            const target = new THREE.Vector3();

            // u = constant, v varies
            for (let i = 0; i <= uCount; i++) {
                const u = i / (uCount + 1);
                const points = [];

                for (let j = 0; j <= segments; j++) {
                    const v = j / segments;
                    this.surface.parametrization()(u, v, target);
                    points.push(target.clone());
                }

                this.#addLine(points, material);
            }

            // v = constant, u varies
            for (let i = 0; i <= vCount; i++) {
                const v = i / (vCount + 1);
                const points = [];

                for (let j = 0; j <= segments; j++) {
                    const u = j / segments;
                    this.surface.parametrization()(u, v, target);
                    points.push(target.clone());
                }

                this.#addLine(points, material);
            }
        }

        clear() {
            for (const line of this.lines) {
                this.group.remove(line);
                line.geometry.dispose();
            }

            this.lines = [];

            if (this.material) {
                this.material.dispose();
                this.material = null;
            }
        }

        visible() {
            return this.lines.length !== 0;
        }

        dispose() {
            this.clear();        // eigen GPU-resources
            super.dispose();     // group uit parent + refs los
            this.surfaceDefinition = null;
        }
    }

    class CurvatureContoursView extends SurfaceView {
        constructor(parentGroup, surface) {
            super(parentGroup, surface);
            this.pointsObject = null;
            this.material = null;
        }

        buildWith({
                      threshold = 0.05,
                      uCount = 100,
                      vCount = 100,
                      color = 0xffaa00,
                      opacity = 0.8
                  } = {}) {
            this.clear();

            const curvature = new DifferentialGeometry(this.surface.parametrization());
            const points = [];
            for (let i = 0; i <= uCount; i++)
                for (let j = 0; j <= vCount; j++) {
                    const u = i / uCount;
                    const v = j / vCount;
                    const H = curvature.meanCurvature(u, v);
                    if (Math.abs(H) <= threshold) continue;

                    const point = new THREE.Vector3();
                    this.surface.parametrization()(u, v, point);
                    points.push(point);
                }

            if (points.length === 0) return;
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            this.material = new THREE.PointsMaterial({
                size: 0.04,
                color: color,
                opacity: opacity,
                transparent: true
            });

            this.pointsObject = new THREE.Points(geometry, this.material);
            this.group.add(this.pointsObject);
        }

        clear() {
            if (this.pointsObject) {
                this.group.remove(this.pointsObject);
                this.pointsObject.geometry.dispose();
                this.pointsObject.material.dispose();
                this.pointsObject = null;
                this.material = null;
            }
        }

        dispose() {
            this.clear();       // eigen GPU resources
            super.dispose();    // group uit parent + refs los
            this.geometry = null;
            this.surface = null;
        }
    }

    class NormalsView extends SurfaceView {
        constructor(parentGroup, surface, geometry) {
            super(parentGroup, surface);
            this.geometry = geometry;
        }

        #createNormalLines(normalScale, curvatureGain, stride) {
            const pos  = this.geometry.attributes.position;
            const nor  = this.geometry.attributes.normal;
            const uv  = this.geometry.attributes.uv;
            const curvature = new DifferentialGeometry(this.surface.parametrization());
            this.geometry.computeVertexNormals();

            const positions = [];
            const colors    = [];
            for (let i = 0; i < pos.count; i += stride) {
                const x  = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
                const nx = nor.getX(i), ny = nor.getY(i), nz = nor.getZ(i);
                const u = uv.getX(i), v = uv.getY(i);
                const K = curvature.gaussianCurvature(u, v);
                const scale = normalScale + curvatureGain * Math.min(Math.abs(K), 1);
                const color = new THREE.Color(0.5 * (nx + 1), 0.5 * (ny + 1), 0.5 * (nz + 1));

                positions.push(x, y, z, x + scale * nx, y + scale * ny, z + scale * nz);
                colors.push(color.r, color.g, color.b, color.r, color.g, color.b);
            }

            const normalsGeometry = new THREE.BufferGeometry();
            normalsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            normalsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ vertexColors: true, depthTest: false });
            return new THREE.LineSegments(normalsGeometry, material);
        }

        buildWith({ normalScale = 0.25, curvatureGain = 1.0, stride = 4 }) {
            this.clear();
            this.helper = this.#createNormalLines(normalScale, curvatureGain, stride);
            this.group.add(this.helper);
        }

        clear() {
            if (!this.helper) return;

            this.group.remove(this.helper);
            this.helper.geometry.dispose();
            this.helper.material.dispose();
            this.helper = null;
        }

        dispose() {
            this.clear();       // alleen eigen resources
            super.dispose();    // verwijdert group uit parent
            this.geometry = null;
            this.surface = null;
        }
    }

    class DifferentialGeometry {
        constructor(parametrization, { eps = 1e-4 } = {}) {
            this.parametrization = parametrization;
            this.eps = eps;
        }

        derivatives(u, v) {
            const e = this.eps;

            // posities
            const p   = new THREE.Vector3();

            const pu1 = new THREE.Vector3();
            const pu0 = new THREE.Vector3();
            const pv1 = new THREE.Vector3();
            const pv0 = new THREE.Vector3();

            const pu1v1 = new THREE.Vector3();
            const pu1v0 = new THREE.Vector3();
            const pu0v1 = new THREE.Vector3();
            const pu0v0 = new THREE.Vector3();

            // sample
            this.parametrization(u, v, p);

            this.parametrization(u + e, v, pu1);
            this.parametrization(u - e, v, pu0);
            this.parametrization(u, v + e, pv1);
            this.parametrization(u, v - e, pv0);

            this.parametrization(u + e, v + e, pu1v1);
            this.parametrization(u + e, v - e, pu1v0);
            this.parametrization(u - e, v + e, pu0v1);
            this.parametrization(u - e, v - e, pu0v0);

            // eerste afgeleiden (centraal)
            const Xu = pu1.clone().sub(pu0).multiplyScalar(1 / (2 * e));
            const Xv = pv1.clone().sub(pv0).multiplyScalar(1 / (2 * e));

            // tweede afgeleiden (centraal)
            const Xuu = pu1.clone()
                .sub(p.clone().multiplyScalar(2))
                .add(pu0)
                .multiplyScalar(1 / (e * e));

            const Xvv = pv1.clone()
                .sub(p.clone().multiplyScalar(2))
                .add(pv0)
                .multiplyScalar(1 / (e * e));

            const Xuv = pu1v1.clone()
                .sub(pu1v0)
                .sub(pu0v1)
                .add(pu0v0)
                .multiplyScalar(1 / (4 * e * e));

            return { Xu, Xv, Xuu, Xuv, Xvv };
        }

        normal(u, v) {
            const { Xu, Xv } = this.derivatives(u, v);
            return Xu.clone().cross(Xv).normalize();
        }

        firstFundamentalForm(u, v) {
            const { Xu, Xv } = this.derivatives(u, v);
            return {
                E: Xu.dot(Xu),
                F: Xu.dot(Xv),
                G: Xv.dot(Xv)
            };
        }

        secondFundamentalForm(u, v) {
            const { Xu, Xv, Xuu, Xuv, Xvv } = this.derivatives(u, v);
            const N = Xu.clone().cross(Xv).normalize();
            return {
                e: Xuu.dot(N),
                f: Xuv.dot(N),
                g: Xvv.dot(N)
            };
        }

        meanCurvature(u, v) {
            const { E, F, G } = this.firstFundamentalForm(u, v);
            const { e, f, g } = this.secondFundamentalForm(u, v);

            const denom = 2 * (E * G - F * F);
            return denom !== 0 ? (e * G - 2 * f * F + g * E) / denom : 0;
        }

        gaussianCurvature(u, v) {
            const { E, F, G } = this.firstFundamentalForm(u, v);
            const { e, f, g } = this.secondFundamentalForm(u, v);

            const denom = (E * G - F * F);
            return denom !== 0 ? (e * g - f * f) / denom : 0;
        }

        principalCurvatures(u, v) {
            const H = this.meanCurvature(u, v);
            const K = this.gaussianCurvature(u, v);

            const disc = Math.max(0, H * H - K);
            const squareRoot = Math.sqrt(disc);

            return { k1: H + squareRoot, k2: H - squareRoot };
        }
    }

    class Ring {
        constructor(parentGroup, boundingBox, {
            ringRadius = 1.75,
            verticalOffset = -1,
            activeCategory = Category.MISC,
            rotationSpeed=0.01,
            selectionLerp=0.08
        } = {}) {
            this.group = new THREE.Group();
            parentGroup.add(this.group);
            this.surfaces = [];
            this.boundingBox = boundingBox;
            this.ringRadius = ringRadius;
            this.activeCategory = activeCategory;
            this.rotationSpeed = rotationSpeed;
            this.selectionLerp = selectionLerp;
            this.verticalOffset = verticalOffset;
            this.ringTargetRotation = null;
            this.selectedSurface = null;
        }

        #rotationToTargetSurfaceIsNeeded = () => this.ringTargetRotation !== null;

        #rotate() {
            const delta = this.ringTargetRotation - this.group.rotation.y;
            const shortest = ((delta + Math.PI) % (2 * Math.PI)) - Math.PI;
            this.group.rotation.y += shortest * this.selectionLerp;

            if (Math.abs(shortest) < 0.001) {
                this.group.rotation.y = this.ringTargetRotation;
                this.ringTargetRotation = null;
            }
        }

        #setTargetRotation(selectedSurface) {
            const local = selectedSurface.position();
            const angle = Math.atan2(local.x, local.z);
            this.ringTargetRotation = -angle + Math.PI * .45;
        }

        #placeAndShowSurface = (surface, index) => {
            const angle = 2 * Math.PI * index / this.visibleRingItems().length;
            const position = new THREE.Vector3(this.ringRadius * Math.cos(angle), this.verticalOffset, this.ringRadius * Math.sin(angle));
            surface.moveTo(position);
            surface.show();
        };

        #redistribute() {
            this.surfaces.forEach(surface => surface.hide());
            this.visibleRingItems().forEach((surface, index) => this.#placeAndShowSurface(surface, index));
        }

        #onSelectedSurface(selectedRingSurface) {
            this.#setTargetRotation(selectedRingSurface);
            if (this.selectedSurface) this.selectedSurface.onDeselect();
            selectedRingSurface.onSelect();
            this.selectedSurface = selectedRingSurface;
        }

        add(surfaces) {
            surfaces.forEach(surfaceData => {
                const selectorSurface = new SurfaceSelectorView(this.group, new Surface(surfaceData), {});
                Utils.fitGroupToBox(
                    selectorSurface.group,
                    selectorSurface.boundingBox(),
                    boundingBox,
                    {alignY: "min", padding: 1.1}
                );
                this.surfaces.push(selectorSurface);
            });
            this.#redistribute();
        }

        changeActiveCategoryTo(category) {
            this.activeCategory = category;
            this.#redistribute();
        }

        findSurfaceByName = (name) => this.surfaces.find(surface => surface.data().meta.name === name);
        findSurfaceByMesh = (mesh) => this.surfaces.find(surface => surface.selectableObject() === mesh);
        getSelectableObjects = () => this.visibleRingItems().map(surface => surface.selectableObject());
        rotateRingToSelectedSurface = () => { if (this.#rotationToTargetSurfaceIsNeeded()) this.#rotate(); };
        rotateSurfaces = () => this.visibleRingItems().forEach(surface => surface.rotateBy(this.rotationSpeed));
        onSelectTo = (selectedRingSurface) => this.#onSelectedSurface(selectedRingSurface);
        visibleRingItems = () => this.surfaces.filter(surface => surface.data().meta.category === this.activeCategory);
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x131313);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);
    const scenery = new Scenery(scene, worldGroup);

    const axesGroup = new THREE.Group();
    worldGroup.add(axesGroup);
    const axes = new MatlabAxes(axesGroup);

    const surfaceDefinition = surfaces[14];
    const visualizationParameters = new ViewParameters();
    let surfaceInAxes = create(surfaceDefinition, visualizationParameters, scenery, axes);

    const boundingBox = surfaceInAxes.boundingBox();
    Utils.scaleBox3(boundingBox, 0.22)
    const ring = new Ring(worldGroup, surfaceInAxes, boundingBox);
    ring.add(surfaces);
    ring.changeActiveCategoryTo(surfaceDefinition.meta.category);
    const selectedRingSurface = ring.findSurfaceByName(surfaceDefinition.meta.name);
    ring.onSelectTo(selectedRingSurface);

    const controlsGui = new ControlsGui(worldGroup, surfaceInAxes, axes, ring, visualizationParameters);

    const bbox = new THREE.Box3();
    bbox.setFromObject( axesGroup );
    scenery.fitToBoundingBox(bbox, {padding: 1.2, translationY: -1});

    function create(surfaceData, visualizationParameters, scenery, axes) {
        scenery.updateSurfaceData(surfaceData);
        const surfaceInAxes = new DisplayedSurfaceView(axesGroup, new Surface(surfaceData), visualizationParameters);
        surfaceInAxes.resetTransform();
        Utils.fitGroupToBox(
            surfaceInAxes.group,
            surfaceInAxes.boundingBox(),
            axes.boundingBox(),
            { alignY: "min", padding: 1.1 }
        );
        return surfaceInAxes;
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    canvas.addEventListener("pointerdown", event => {
        mouse.x = (event.offsetX / canvas.clientWidth) * 2 - 1;
        mouse.y = -(event.offsetY / canvas.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, scenery.camera);

        const hits = raycaster.intersectObjects(
            ring.getSelectableObjects(),
            false // IMPORTANT: no recursion
        );

        if (!hits.length) return;

        const selectedMesh = hits[0].object;
        const selectedRingSurface = ring.findSurfaceByMesh(selectedMesh);
        surfaceInAxes.dispose();
        surfaceInAxes = create(selectedRingSurface.data(), visualizationParameters, scenery, axes);
        ring.onSelectTo(selectedRingSurface);
        controlsGui.updateSurfaceWith(surfaceInAxes);
    });

    function animate() {
        requestAnimationFrame(animate);
        ring.rotateRingToSelectedSurface();
        ring.rotateSurfaces();
        scenery.render();
    }

    animate();
</script>